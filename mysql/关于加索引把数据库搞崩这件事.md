本文基于的数据库环境：MySQL 8.0.12，MySQL 客户端 IntelliJ IDEA 2021.2.3 Database（重要）

# 表级锁

MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)，这两中锁都是由 Server层实现的。

## 表锁

表锁的语法是 `lock tables table_name read/write`。需要解锁的话，可以用 `unlock tables` 主动释放锁，也可以在客户端断开的时候自动释放。这里的锁有两种分别是读锁（read）和写锁（write），简单解释一下这里的读写分别指什么：

- 读：DML 中的 Select
- 写：所有的 DDL，和除 Select 以外的 DML

需要注意，`lock tables` 语法除了会限制别的线程的读写外，也限定了本线程接下来的读写。举个例子，如果在某个**线程 A 中**执行 `lock tables t1 read, t2 write` ：

- 线程 A：
  - t1：只能执行 Select 操作
  - t2：可以执行任意的 DML 和 DDL 操作
- 其他线程：
  - t1：可以执行 Select 操作；可以加读锁（`lock tables table_name read`）
  - t2：DML、DDL 和 `lock tables table_name read/write` 都会被阻塞

在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。

## 元数据锁（meta data lock，MDL)

在 MySQL 5.5 版本中引入了 MDL，**MDL 不需要显式使用，在访问一个表的时候会被自动加上**。**MDL 作用是防止 DDL 和 DML 并发的冲突，用于解决或者保证 DDL 操作与 DML 操作之间的一致性。**你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。明确 MDL 的几个基本原则：

1. DML 加会加读锁，DDL 会加写锁
2. 读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。
3. 读写锁之间、写锁之间是互斥的。因此当一个线程对一个表进行 DDL 操作时，其他表对该表的所有 DML 和 DDL 操作都会被阻塞
4. MySQL 对申请 MDL 锁的操作会形成一个队列，队列中写锁获取优先级高于读锁。一旦出现写锁等待，不但当前操作会被阻塞，同时还会阻塞后续该表的所有操作

### 场景演示

|                 session A                 |           session B           |              session C               |               session D               |
| :---------------------------------------: | :---------------------------: | :----------------------------------: | :-----------------------------------: |
| begin;<br />select * from table1 limit 1; |                               |                                      |                                       |
|                                           | select * from table1 limit 1; |                                      |                                       |
|                                           |                               | alter table add column1 int;（阻塞） |                                       |
|                                           |                               |                                      | select * from table1 limit 1;（阻塞） |

**现象的解释：**

- session A 获取 MDL 读锁，因为开启了事务并且没有 commit，所以会一直持有读锁
- session B 获取的 MDL 的读锁，读锁之间不互斥，所以 session B 不会被阻塞
- session C 需要获取 MDL 的写锁，因为session A 还在持有读锁，读锁和写锁互斥，所以 session C 会被阻塞等待获取写锁
- session D 需要获取读锁，因为 session C 在等待获取写锁，根据上面基本原则的第四条，在 session C 获取写锁之前 session D 也会被阻塞

所以这里就有一个非常值得注意的地方，当一个 DDL 一个热表，并且该 DDL 操作被阻塞时，后面的 DML 操作都会被阻塞，这是非常危险的。

### 关于 Online DDL

由于 DDL 执行时如果锁表的话会严重影响性能，不锁表又难搞定操作期间 DML 语句的影响，于是 MySQL 推出了全新的 Online DDL概念， Online DDL 中的 ”Online“ 可以简单理解为，在 DDL 的过程中其他的线程是否可以进行 DML，如果可以那么就是 “Online” 的。

在 执行 DDL 操作时，可以通过从句 `ALGORITHM=?` 指定 DDL 执行时使用的算法，自 MySQL 8.0.12 起，支持的算法有三种：COPY、INPLACE 和 INSTANT，当然如果不指定 `ALGORITHM` ，DDL 默认的算法就是 `ALGORITHM=DEFAULT`， MySQL按照 INSTANT、INPLACE 和  COPY 的顺序自动选择合适的模式，如果你通过 `ALGORITHM` 指定了 DDL 不支持的算法，MySQL 会抛出异常。这里不讨论这三种算法的具体实现细节，只讨论哪种算法是 ”Online“ 的，先说结论：

1. COPY：MySQL 5.6 之前使用的算法，如果采用这种算法，DDL 期间会阻塞后续的所有 DML 和 DDL，**也就是 这种算法不 ”Online“**
2. INPLACE：MySQL 5.6 之后出现的新算法，**整体上可以看作是 ”Online“ 的**
3. INSTANT：MySQL 8.0.12 提出的新算法，只需修改数据字典中的元数据，无需拷贝数据也无需重建整表，同样，也无需加排他 MDL 锁，原表数据也不受影响。整个DDL过程几乎是瞬间完成的，也不会阻塞 DML，**也就是这种算法 ”Online“ **

这里解释一下为什么说 **INPLACE 整体上是 ”Online“** 的呢，实际上 DDL 操作在执行时，不管何种算法，都会经历三个阶段：准备阶段（prepare）、执行阶段（DDL）和 提交阶段（commit），INPLACE 实现  Online DDL 的过程可以简单概况为一下这 5 步：

1. 拿 MDL 写锁
2. 降级成 MDL 读锁
3. 执行 DDL（真正耗时的地方）
4. 升级成 MDL 写锁
5. 释放 MDL 锁

因为当真正进行耗时的 DDL 操作，降级成了读锁，其他线程可以对该表进行 DML，大大降低了 DDL 对该表的影响，提高该表的并发，只有在读写锁升降级的时候才会阻塞 DML，所以说 **INPLACE 整体上是 ”Online“**。

**那么我怎么知道哪种 DDL 支持那种算法，并且是否是 ”Online“ 的呢？**

其实 [MySQL 的官方](https://dev.mysql.com/doc/refman/8.0/en/innodb-online-ddl-operations.html)给出了说明，以**添加非主键索**引为例，这里可以看到，他是不支持 INSTANT 算法，但是支持 INPLACE 算法，并且他是 ”Online“ 的。

![](http://qiniu.zhouhongyin.top/2023/03/15/1678895671-image-20230315235431337.png)

> 特别说明：
>
> 1. COPY 算法一定不是 Online 的
> 2.  INSTANT 算法一定是 Online 的
> 3. INPLACE 不一定是 Online 的（大部分都是 Online 的），比如说上图的 **Adding a** `FULLTEXT` **index** 操作，虽然支持 INPLACE ，但是他却不是 Online 的

### 关于我对常见 DDL 的测试

> 特别说明，数据库版本和客户端要和本文使用的保持一致否则可能会出现测试结果不一样的情况。

测试场景说明：将 session B 中的语句换成以下几种 DDL 语句后，当 session A commit 后，session B 和 session C 的阻塞情况：

![](http://qiniu.zhouhongyin.top/2023/03/10/1678435279-image-20230310160117568.png)

#### ALTER table table1 ADD COLUMN column1 int

![](http://qiniu.zhouhongyin.top/2023/03/15/1678889536-image-20230315221216716.png)

session B 和 session C 都不会被阻塞

1. session B 获取 MDL 写锁，并且执行完 DDL，后释放锁
2. 在session B 执行完毕后，session C 获取 MDL 读锁，执行查询

#### ALTER TABLE table1 MODIFY column1

同 `ALTER TABLE table1 ADD column1`

#### ALTER TABLE table1 DROP COLUMN colum1

![image-20230310155956302](http://qiniu.zhouhongyin.top/2023/03/10/1678435202-image-20230310155956302.png)

session B 被阻塞，session C 执行

1. session B 拿 MDL 写锁
2. session B 降级成 MDL 读锁
3. session C 拿 MDL 读锁
4. session B 真正做 DDL
5. session B 升级成 MDL 写锁（阻塞）

> 特殊情况说明：当表中没有数据存在时，session B 和 session C 都会被阻塞

#### ALTER table table1 ADD INDEX index1(column1)

![image-20230310160035645](http://qiniu.zhouhongyin.top/2023/03/10/1678435237-image-20230310160035645.png)

session B 和 session C 仍然被阻塞（不确定原因，不知道是不是 MySQL 的 bug）

解决方案：

1. 设置锁的超时时间：

```sql
-- 单位 秒,只在当前会话中生效
set lock_wait_timeout=10
ALTER table table1 ADD INDEX index1(column1)
```

2. 使用表锁

```sql
lock table table1 write;
ALTER table table1 ADD INDEX index1(column1)
unlock table
```

### 如何安全地给小表加字段

首先我们要解决长事务，事务不提交，就会一直占着 MDL 锁。在 MySQL 的 **information_schema** 库的 **innodb_trx** 表中，你可以查到当前执行中的事务，通过 `SELECT * FROM information_schema.innodb_trx`。如果你要做 DDL 变更的表刚好有长事务在执行，要考虑先暂停 DDL，或者 `kill` 掉这个长事务。

但考虑一下这个场景。如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，你该怎么做呢？

这时候 kill 可能未必管用，因为新的请求马上就来了。比较理想的机制是，**在 alter table 语句里面设定等待时间**，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过程。

```sql
ALTER TABLE tbl_name NOWAIT add column ...
ALTER TABLE tbl_name WAIT N add column ...
```

或者

```sql
-- 单位 秒,只在当前会话中生效
set lock_wait_timeout=10
ALTER TABLE auth_account ADD ...
```

> 事务或者锁的排查命令：
>
> ```sql
> SELECT * FROM information_schema.INNODB_TRX;
> 
> show processlist;
> 
> select * from performance_schema.metadata_locks;
> 
> SELECT * FROM sys.schema_table_lock_waits
> 
> KILL 120
> 
> SELECT version()
> ```
