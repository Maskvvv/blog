---
title: 算法 - 动态规划方法论
date: 2021-9-22
updated: 2021-9-22
tags:
  - 算法
  - LeetCode
categories:
  - 算法
  - 动态规划
  - 算法 - 动态规划方法论
---

![](%E7%AE%97%E6%B3%95%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%96%B9%E6%B3%95%E8%AE%BA/algorithms.jpg)

<!-- more -->

# 一、动态规划题目的特点
## 1.1 计数
- 有多少中方式走到右下角
- 有多少种方法选出 k 个数使得和是 Sum
## 1.2 求最大最小值
- 从左上角走到右下角路径的最大数字和
- 最长上升子序列长度
## 1.3 求存在性
- 取石子游戏,先手是否必胜
- 能不能选出 k 个数使得和是 Sum
# 二、动态规划步骤

## 2.1 确定状态

- 状态在动态规划中的作用属于定海神针
- 简单的说，接动态规划的时候需要开一个数组，数组的每一个元素 f[i] 或者 f\[i][j] 代表什么
- 确定状态需要的两个意识
  - 最后一步
  - 子问题

# 三、例题
## 2.1 最大最小值型动态规划

### 2.1.1 LintCode 669: Coin Change

你有三种硬币，分别面值 2 元，5 元和 7 元，每种硬币都有足够多

买一本书需要 27 元

如何用最少的硬币组合正好付清，不需要对方找钱

#### 解题过程

##### 动态规划组成部分一：确定状态

- 最少永多少枚硬币可以拼出 27-a~k~
- 原问题是最少永多少枚硬币频出 27
- 我们将原问题转化成了一个子问题，而且规模更小：27 - a~k~
- 为了简化定义，我们设状态 f(X) = 最少用多少枚硬币拼出 X

![](%E7%AE%97%E6%B3%95%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%96%B9%E6%B3%95%E8%AE%BA/image-20210922204438771.png)

但我们现在还不知道那枚 a~k~ 是多少，最后那枚硬币 a~k~ 只可能是 2，5，7

- 如果 a~k~ 是 2， f(27) 应该是 f(27-2) + 1（加上最后这一枚硬币2）
- 如果 a~k~ 是 5， f(27) 应该是 f(27-5) + 1（加上最后这一枚硬币5）
- 如果 a~k~ 是 7， f(27) 应该是 f(27-7) + 1（加上最后这一枚硬币7）

除此之外，没有其他的可能了，所以需要最少的硬币书为：

![](%E7%AE%97%E6%B3%95%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%96%B9%E6%B3%95%E8%AE%BA/image-20210922210033584.png)

##### 动态规划组成部分二：转移方程

- 设状态 f[x] = 最少用多少枚硬币拼出 x
- 对于任意 x
  - ![](%E7%AE%97%E6%B3%95%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%96%B9%E6%B3%95%E8%AE%BA/image-20210923083809373.png)

##### 动态规划组成部分三：初始条件和边界性

- f[x] = min{f[x - 2] + 1, f[x - 5] + 1, f[x - 7] + 1}
- 两个问题：x - 2，x - 5 或者 x - 7 小于 0 怎么办？什么时候停下来？
- 如果不能拼出 Y ，就定义 f[Y] = 正无穷
  - 例如 f[-1] = f[-2] = ... = 正无穷
- 所以 f[1] = min{f[-1] + 1, f[-4] + 1, f[-6] + 1} = 正无穷，表示拼不出来 1
- 初始条件：f[0] = 0

> 初始条件：用转移方程算不出来，但有需要他的定义，所以需要提前手工定义。

##### 动态规划组成部分四：计算顺序

- 拼出 x 所需要的最少硬币数：f[x] = min{f[x - 2] + 1, f[x - 5] + 1, f[x - 7] + 1}
- 初始条件： f[0] = 0
- 然后计算 f[1]，f[2]，...，f[27]
- 当我们计算 f[x] 时，f[x - 2]，f[x - 5]，f[x - 7] 都已经的到结果了

> 与递归算法相比，该算法没有任何重复计算，时间复杂度为：n*m

### 小结：

求最值性动态规划。

动态规划步骤：

- 确定状态
  - 最后一步（最优策略中使用的最后一枚硬币 a~k~）
  - 化成子问题（最少的硬币拼出最小的面值 27 - a~k~）
- 转移方程
  - f[x] = min{f[x - 2] + 1, f[x - 5] + 1, f[x - 7] + 1}
- 初始条件和边界情况
  - f[0] = 0，如果不能拼出 Y，f[Y] = 正无穷
- 计算顺序
  - f[0]，f[1]，f[2]，...

### 解法：

#### 递归法

```java
int f(int x) {                                // f(x)=最少永多少枚硬币拼出x
    if (x == 0) return 0;                     // 0 元钱只要 0 枚硬币
    int res = MAX_VALUE;                      // 初始化无穷大
    if (x >= 2) {                             // 最后一枚硬币是 2 元
        res = Math.min(f(x - 2) + 1, res);    
    }
    if (x >= 5) {                             // 最后一枚硬币是 5 元
        res = Math.min(f(x - 5) + 1, res);
    }
    if (x >= 7) {                             // 最后一枚硬币是 7 元
        res = Math.min(f(x - 7 ) + 1, res);
    }
    return res;
}
```

**递归解法出现的问题：**

有重复计算的情况。

![](%E7%AE%97%E6%B3%95%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%96%B9%E6%B3%95%E8%AE%BA/image-20210923083543705.png)

#### 动态规划法

```java
public class Solution {
    // A：硬币种类，M：需要拼成的数额
    public int coinChange(int [] A, int M) {
        int[] f = new int[M + 1];
        int n = A.length; // 值为硬币种类数
        
        int i, j;
        // 初始化
        for (i = 1; i <= M; ++i) {
            f[i] = Integer.MAX_VALUE;
            // last coin A[j]
            // f[x] = min{f[x - A[0]] + 1, ... , f[x - A[n -1]] + 1}
            for (j = 0; j < n; ++j) {
                if (i >= A[j] && f[i - A[j]] != Integer.MAX_VALUE) {
                    f[i] = Math.min(f[i - A[j]] + 1, f[i]);
                }
            }
        }
        
        if (f[M] == Integer.MAX_VALUE) {
            f[M] = -1;
        }
        
        return f[M];
        
    }
}
```

## 2.2 计数型动态规划

### 2.2.1 LintCode 114: Unique Paths

给定 m 行 n 列的网络，有一个机器人从左上交 (0, 0) 出发，每一步可向下或向右走一步，问又多少种不同的方式走到右下角。

![](%E7%AE%97%E6%B3%95%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%96%B9%E6%B3%95%E8%AE%BA/image-20210924091324364.png)

#### 解题过程

##### 动态规划组成部分一：确定状态

**最后一步：**

- 无论机器人用何种方式达到右下角，总有最后挪动的那一步（向右或者向下）
- 设右下角的坐标为 (m -1, n -1)，那么机器人的前一步一定在 (m -2, n - 1) 或者 (m -1, n - 2)

**子问题**

- 如果机器人有 X 种方式从左上角走到 (m -2, n - 1)，有 Y 种方式从左上角走到 (m -1, n - 2)，则机器人有 X + Y 种方式走到 (m -1, n -1)
- 问题转化为，机器人有多少种返时从左上角走到  (m -2, n - 1) 和 (m -1, n - 2)

##### 动态规划组成部分二：转移方程

![](%E7%AE%97%E6%B3%95%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%96%B9%E6%B3%95%E8%AE%BA/image-20210924093319284.png)

##### 动态规划组成部分三：初始条件和边界性

初始条件：f\[0][0] = 1，因为机器人只有一种方式到右上角

边界情况：i = 0 或 j = 0，则前一步只能有一个方向过来，所以 f\[0][j] = 1，f\[i][0] = 1

##### 动态规划组成部分四：计算顺序

![](%E7%AE%97%E6%B3%95%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%96%B9%E6%B3%95%E8%AE%BA/image-20210924094137773.png)

时间复杂度（计算步数）：O(MN)，空间复杂度（）数组大小：O(MN)