**实例一**

1. 查看full gc的频率和时间，以及回收前和回收后老年代回收了多少垃圾 
2. 如果回收的垃圾很多，比如 80%->20% 考虑业务是否有可以优化的地方，是否有同类型对象短时间大量过期，可以在内存高位执行 dump  然后等full gc 后再dump做对比 
3. 如果回收的垃圾比较少，执行dump，查看哪些对象占用了大部分空间，是不是发生了内存泄露，引用都被哪些对象持有，是否应该及时释放等。

**实例二**

遇到过线上系统卡顿的情况。业务反应系统登录不上，用 `top -p -h` 和 `jstack` 发现是 gc 线程（数量和内核数一致且线程编号连续），排查内存中对象数量 (`jmap -histo:live javaPid`) 和 请求日志( elk 或者log4j日志)，发现是生成 excel 数据太多，一下子把老年代给撑爆了，导致疯狂的 `full gc`。 后将 excel 生成类临时替换成 SXSSFWorkbook 就暂时没有出现过。

**实例三**

- 如果发现 Young GC 非常耗时，这很可能就是因为新生代太大了，我们可以考虑减小新生代的最小比例。

  降低其最大值同样对降低 Young GC 延迟有帮助。

  如果我们直接为 G1 设置较小的延迟目标值，也会起到减小新生代的效果，虽然会影响吞吐量。

- 如果是 Mixed GC 延迟较长，我们应该怎么做呢？

  还记得前面说的，部分 Old region 会被包含进 Mixed GC，减少一次处理的 region 个数，就是个直接的选择之一。我在上面已经介绍了 G1OldCSetRegionThresholdPercent 控制其最大值，还可以利用下面参数提高 Mixed GC 的个数，当前默认值是 8，Mixed GC 数量增多，意味着每次被包含的 region 减少。