# VIM 编辑器

VI是Unix操作系统和类Unix操作系统中最通用的文本编辑器。
VIM编辑器是从VI发展出来的一个性能更强大的文本编辑器。可以主动的以字体颜色辨别语法的正确性，方便程序设计。VIM 与VI编辑器完全兼容。

## VIM 工作模式转换

![](http://qiniu.zhouhongyin.top/2023/10/03/1696321693-image-20231003162813127.png)

## 一般模式

刚刚启动 vi/vim，便进入了一般模式(默认模式)。此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。在此模式可以复制黏贴，删除等操作。若想要编辑文本，进入一般模式，按下i，切换到编辑模式。

### 复制粘贴删除

| 命令 |                    说明                    |
| :--: | :----------------------------------------: |
|  yy  |         复制游标所在的那一行(常用)         |
| nyy  |     n 为数字。复制光标所在的向下 n 行      |
| y1G  |      复制游标所在行到第一行的所有数据      |
|  yG  |     复制游标所在行到最后一行的所有数据     |
|  y0  | 复制光标所在的那个字符到该行行首的所有数据 |
|  y$  | 复制光标所在的那个字符到该行行尾的所有数据 |
|  p   |       将已复制的数据在光标下一行贴上       |
|  P   |       将已复制的数据在光标上一行贴上       |
|  dd  |        删除游标所在的那一整行(常用)        |
| ndd  |     n 为数字。删除光标所在的向下 n 行      |
| d1G  |       删除光标所在到第一行的所有数据       |
|  dG  |      删除光标所在到最后一行的所有数据      |
|  d$  |    删除游标所在处，到该行的最后一个字符    |
|  d0  |   删除游标所在处，到该行的最前面一个字符   |
|  x   |        向后删除一个字符，相当于 del        |
|  X   |     向前删除一个字符，相当于backspace      |
|  nx  |      n 为数字，连续向后删除 n 个字符       |

### 撤回

|  命令  |      说明      |
| :----: | :------------: |
|   u    | 复原前一个动作 |
| Ctrl+r | 重做上一个动作 |

### 移动光标

|   命令    |                     说明                     |
| :-------: | :------------------------------------------: |
| n< space> | n 表示数字，光标会向右移动这一行的 n 个字符  |
| 0 或Home  |          移动到这一行的最前面字符处          |
|  $ 或End  |          移动到这一行的最后面字符处          |
|     H     | 光标移动到这个屏幕的最上方那一行的第一个字符 |
|     M     |  光标移动到这个屏幕的中央那一行的第一个字符  |
|     L     | 光标移动到这个屏幕的最下方那一行的第一个字符 |
|     G     |           移动到这个档案的最后一行           |
|    nG     |      n 为数字。移动到这个档案的第 n 行       |
|    gg     |            移动到这个档案的第一行            |
|  h 或 ←   |             光标向左移动一个字符             |
|  j 或 ↓   |             光标向下移动一个字符             |
|  k 或 ↑   |             光标向上移动一个字符             |
|  l 或 →   |             光标向右移动一个字符             |
|  Ctrl+ f  |    屏幕向下移动一页，相当于Page Down按键     |
| Ctrl + b  |     屏幕向上移动一页，相当于Page Up按键      |
|  Ctrl+ d  |               屏幕向下移动半页               |
| Ctrl + u  |               屏幕向上移动半页               |

### 搜索

| 操作 |                        说明                        |
| :--: | :------------------------------------------------: |
|  /n  | n为要搜索的内容。向光标之下寻找一个名称为n的字符串 |
|  ?n  |      向光标之上寻找一个字符串名称为n的字符串       |
|  n   |                重复前一个搜寻的动作                |
|  N   |         与 n 相反，反向进行前一个搜寻动作          |

## 编辑模式

在一般模式之中，只要按下 i, o, a 等字符就可以进入输入模式。在编辑模式当中，左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。这个时候，键盘上除了 Esc 这个按键之外，其他的按键都可以视作为一般的输入按钮。

| 操作 |                             说明                             |
| :--: | :----------------------------------------------------------: |
| i, I | i 为从目前光标所在处输入， I 在目前所在行的第一个非空格符处开始输入 |
| a, A | a 为从目前光标所在的下一个字符处开始输入， A 为从光标所在行的最后一个字符处开始输入 |
| o, O | o 为在目前光标所在的下一行处输入新的一行； O 为在目前光标所在的上一行处输入新的一行 |
| r, R | r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止 |

## 命令模式

在一般模式之中，只要按下 ：或 / 就可以进入命令模式。

|     操作      |                             说明                             |
| :-----------: | :----------------------------------------------------------: |
|      :w       |                             保存                             |
|      :w!      | 若文件属性为只读时，强制写入该档案。不过，能不能写入， 还跟你对该档案的档案权限有关 |
|      :q       |                             退出                             |
|      :q!      |                           强制退出                           |
|      :wq      |                          保存并退出                          |
|    :set nu    |                           显示行号                           |
|   :set nonu   |                           取消行号                           |
|     :noh      |                         取消高亮显示                         |
|  :s/old/new   |              替换当前匹配到的第一个 old 为 new               |
| :s/old/new/g  |               替换当前匹配到所有的 old 为 new                |
|  :%s/old/new  |          替换文档中每一行匹配到的第一个 old 为 new           |
| :%s/old/new/g |              替换文档中匹配到所有的 old 为 new               |

# 系统管理

## `systemctl` 命令

systemctl命令来自于英文词组”system control“的缩写，其功能是用于管理系统服务。从RHEL/CentOS7版本之后初始化进程服务init被替代成了systemd服务，systemd初始化进程服务的管理是通过systemctl命令完成的，从功能上涵盖了之前service、chkconfig、init、setup等多条命令的大部分功能。

### 查看服务的方法

`/usr/lib/systemd/system`

### 命令使用方法

`systemctl start | stop | restart | status 服务名`

|            命令            |        说明        |
| :------------------------: | :----------------: |
|           start            |      启动服务      |
|            stop            |      停止服务      |
|          restart           |      重启服务      |
|           enable           |  使某服务开机自启  |
|          disable           | 关闭某服务开机自启 |
|           status           |    查看服务状态    |
| list -units --type=service | 列举所有已启动服务 |

### 例子

```shell
# 启动指定的服务
systemctl start sshd
# 停止指定的服务
systemctl stop sshd
# 重启指定的服务
systemctl restart sshd
# 查看指定服务的运行状态
systemctl status sshd
# 将指定的服务加入到开机启动项中
systemctl enable sshd
# 将指定的服务从开机启动项中取消
systemctl disable sshd
# 显示系统中所有已启动的服务列表信息
systemctl list-units --type=service
```

# 文件常用命令

## `>` & `>>`

`>` 输出重定向和 `>>` 追加

|        命令         |            说明             |
| :-----------------: | :-------------------------: |
|    ls -l > 文件     | 将列表的内容写入文件a.txt中 |
|   ls -al >> 文件    | 列表的内容追加到文件的末尾  |
|  cat 文件1 > 文件2  |  将文件1的内容覆盖到文件2   |
| echo “内容” >> 文件 |      将内容写入到文件       |

## `pwd`

pwd 命令来自于英文词组”print working directory“的缩写，其功能是用于显示当前工作目录的路径，即显示所在位置的绝对路径。

```shell
# 查看当前工作目录路径
pwd

/root/shell
```

## `cd`

cd 命令来自于英文词组”change directory“的缩写，其功能是用于更改当前所处的工作目录，路径可以是绝对路径，也可以是相对路径，若省略不写则会跳转至当前使用者的家目录。~ 也表示为 home 目录 的意思， . 则是表示目前所在的目录，..则表示目前目录位置的上一层目录。


| 参数 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| -P   | 如果切换的目标目录是一个符号链接，则直接切换到符号链接指向的目标目录 |
| -L   | 如果切换的目标目录是一个符号链接，则直接切换到符号链接名所在的目录 |
| –    | 仅使用”-“选项时，当前目录将被切换到环境变量”OLDPWD”对应值的目录 |
| ~    | 切换至当前用户目录                                           |
| ..   | 切换至当前目录位置的上一级目录                               |

```shell
# 切换当前工作目录至/etc
cd /etc

# 切换至当前用户的家目录：
cd ~

# 进入到上一级所在目录（家目录→根目录）
cd ..

# 返回到上一次所在目录（根目录→家目录）
cd -

# 跳到目前目录的上上两层
cd ../..
```

## `ls`

ls 命令来自于英文单词 list 的缩写，其功能是列举出指定目录下的文件名称及其属性。默认不加参数的情况下，ls命令会列出当前工作目录中的文件信息。

|  参数  |                      说明                       |
| :----: | :---------------------------------------------: |
|   -a   |  显示所有文件及目录 (包括以“.”开头的隐藏文件)   |
|   -l   |       使用长格式列出文件及目录的详细信息        |
|   -r   |    将文件以相反次序显示(默认依英文字母次序)     |
|   -t   |             根据最后的修改时间排序              |
|   -A   | 同 -a ，但不列出 “.” (当前目录) 及 “…” (父目录) |
|   -S   |                根据文件大小排序                 |
|   -R   |               递归列出所有子目录                |
|   -d   |     查看目录的信息，而不是里面子文件的信息      |
|   -i   |             输出文件的inode节点信息             |
|   -m   |            水平列出文件，以逗号间隔             |
|   -X   |                按文件扩展名排序                 |
| –color |             输出信息中带有着色效果              |

```shell
# 输出当前目录中的文件（默认不含隐藏文件）
ls

# 输出当前目录中的文件（含隐藏文件）
ls -a

# 输出文件的长格式，包含属性详情信息
ls -l

# 输出指定目录中的文件列表
ls /etc

# 输出文件名称及inode属性块号码
ls -i

# 搭配通配符一起使用，输出指定目录中所有以sd开头的文件名称
ls /dev/sd*

# 依据文件大小进行排序，输出指定目录中文件属性详情信息
ls -Sl /etc

```

## `mkdir`

来自于英文词组 make directories 的缩写，其功能是用来创建目录文件。

| 参数 | 说明                         |
| ---- | ---------------------------- |
| -p   | 递归创建多级目录             |
| -m   | 建立目录的同时设置目录的权限 |
| -z   | 设置安全上下文               |
| -v   | 显示目录的创建过程           |

```shell
# 在当前工作目录中，建立一个目录文件
mkdir dir1

# 在当前工作目录中，创建一个目录文件并设置700权限，不让除所有主以外任何人读、写、执行它
mkdir -m 700 dir2

# 在当前工作目录中，一次性创建多个目录文件
mkdir dir3 dir4 dir5

# 在系统根目录中，一次性创建多个有嵌套关系的目录文件
mkdir -p /dir1/dir2/dir3/dir4/dir5
```

## `rmdir`

来自于英文词组 remove directory 的缩写，其功能是用于删除空目录文件。

rmdir 命令仅能够删除空内容的目录文件，如需删除非空目录时，则需要使用带有-R参数的rm命令进行操作。而rmdir 命令的-p递归删除操作亦不意味着能删除目录中已有的文件，而是要求每个子目录都必须是空的。

| 参数 |                            说明                            |
| :--: | :--------------------------------------------------------: |
|  -p  | 用递归的方式删除指定的目录路径中的所有父级目录，非空则报错 |
|  -v  |                   显示命令的详细执行过程                   |

```shell
# 删除指定的空目录
rmdir Documents

# 删除指定的空目录，及其内的子空目录
rmdir -p Documents

# 删除指定的空目录，并显示删除的过程
rmdir -v Documents
```

## `rm`

来自于英文单词 remove 的缩写，其功能是用于删除文件或目录，一次可以删除多个文件，或递归删除目录及其内的所有子文件。

| 参数 |           说明           |
| :--: | :----------------------: |
|  -f  |  强制删除（不二次询问）  |
|  -i  | 删除前会询问用户是否操作 |
| -r/R |         递归删除         |
|  -v  |  显示指令的详细执行过程  |

```shell
# 删除某个文件，默认会进行二次确认，敲击y进行确认
rm anaconda-ks.cfg 

# 删除某个文件，强制操作不需要二次确认：
rm -f initial-setup-ks.cfg 

# 删除某个目录及其内的子文件或子目录，一并都强制删除
rm -rf Documents

# 强制删除当前工作目录内的所有以.txt为后缀的文件
rm -f *.txt

# 强制清空服务器系统内的所有文件
rm -rf /*
```

## `cp`

来自于英文单词copy的缩写，用于将一个或多个文件或目录复制到指定位置。

| 参数 |                             说明                             |
| :--: | :----------------------------------------------------------: |
|  -f  |             若目标文件已存在，则会直接覆盖原文件             |
|  -i  |              若目标文件已存在，则会询问是否覆盖              |
|  -p  |                  保留源文件或目录的所有属性                  |
|  -r  |                      递归复制文件和目录                      |
|  -d  | 当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录 |
|  -l  |               对源文件建立硬连接，而非复制文件               |
|  -s  |              对源文件建立符号连接，而非复制文件              |
|  -b  |             覆盖已存在的文件目标前将目标文件备份             |
|  -v  |                 详细显示cp命令执行的操作过程                 |
|  -a  |                       等价于“pdr”选项                        |

```shell
# 在当前工作目录中，将某个文件复制一份，并定义新文件名称
cp anaconda-ks.cfg kickstart.cfg

# 在当前工作目录中，将某个目录复制一份，并定义新目录名称
cp -r Documents Doc

复制某个文件时，保留其原始权限及用户归属信息
cp -a kickstart.cfg ks.cfg

# 将某个文件复制到/etc目录中，并覆盖已有文件，不进行询问
cp -f ks.cfg /etc

# 将多个文件一同复制到/etc目录中，如已有目标文件名称则默认询问是否覆盖
cp anaconda-ks.cfg ks.cfg /etc
```

## `mv`

自于英文单词 move 的缩写，用于对文件进行剪切和重命名。

| 参数 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| -i   | 若存在同名文件，则向用户询问是否覆盖                         |
| -f   | 覆盖已有文件时，不进行任何提示                               |
| -b   | 当文件存在时，覆盖前为其创建一个备份                         |
| -n:  | 不要覆盖任何已存在的文件或目录                               |
| -u   | 当源文件比目标文件新，或者目标文件不存在时，才执行移动此操作 |

```shell
# 在当前工作目录中，对某个文件进行剪切后粘贴（重命名）操作
mv anaconda-ks.cfg ks.cfg

# 将某个文件移动到/etc目录中，保留文件原始名称
mv ks.cfg /etc

# 将某个目录移动到/etc目录中，并定义新的目录名称
mv Documents /etc/docs

# 将/home目录中所有的文件都移动到当前工作目录中，遇到已存在文件则直接覆盖
mv -f /home/* .
```

## `cat`

自于英文单词 concatenate 的缩写，其功能是用于查看文件内容。cat命令适合查看内容较少的、纯文本的文件。

| 参数 |              说明              |
| :--: | :----------------------------: |
|  -n  |     显示行数（空行也编号）     |
|  -s  | 显示行数（多个空行算一个编号） |
|  -b  |     显示行数（空行不编号）     |
|  -E  |      每行结束处显示$符号       |

```shell
# 查看某个文件的内容
cat anaconda-ks.cfg

# 查看某个文件的内容，并显示行号
cat -n anaconda-ks.cfg

# 搭配空设备文件和输出重定向操作符，将某个文件内容清空
cat /dev/null > anaconda-ks.cfg 

# 持续写入文件内容，直到碰到EOF符后才会结束并保存
cat > anaconda-ks.cfg << EOF

# 搭配输出重定向操作符，将光盘设备制作成镜像文件
[root@Demo ~]# cat /dev/cdrom > rhel.iso
[root@Demo ~]# ls rhel.iso  -lh
-rw-r--r--. 1 root root 6.7G May  2 00:43 rhel.iso
[root@Demo ~]# file rhel.iso 
rhel.iso: DOS/MBR boot sector; partition 2 : ID=0xef, start-CHS (0x3ff,254,63), end-CHS (0x3ff,254,63), startsector 23128, 19888 sectors
```

## `more`

用于分页显示文本文件内容。如果文本文件中的内容较多较长，使用 cat 命令读取后则很难看清，这时使用 more命令进行分页查看就更加合适，可以把文本内容一页一页的显示在终端界面上，用户每按一次回车即向下一行，每按一次空格即向下一页，直至看完为止。

|   参数    |                             说明                             |
| :-------: | :----------------------------------------------------------: |
|   -num    |                      指定每屏显示的行数                      |
|    -l     | more在通常情况下把 ^L 当作特殊字符, 遇到这个字符就会暂停,-l选项可以阻止这种特性 |
|    -f     |              计算实际的行数，而非自动换行的行数              |
|    -p     |              先清除屏幕再显示文本文件的剩余内容              |
|    -c     |           与-p相似，不滚屏，先显示内容再清除旧内容           |
|    -s     |                    多个空行压缩成一行显示                    |
|    -u     |                          禁止下划线                          |
| +/pattern | 在每个文档显示前搜寻该字(pattern)，然后从该字串之后开始显示  |
|   +num    |                     从第 num 行开始显示                      |

```shell
# 分页显示指定的文本文件内容
more anaconda-ks.cfg 

# 先进行清屏操作，随后以每次10行内容的格式显示指定的文本文件内容
more -c -10 anaconda-ks.cfg

# 分页显示指定的文本文件内容，遇到连续两行以上空白行的情况，则以一行空白行显示
more -s anaconda-ks.cfg

# 从第10行开始，分页显示指定的文本文件内容
more +10 anaconda-ks.cfg 
```

## `less`

less 指令用来分屏查看文件内容，它的功能与 more指 令类似，但是比 more 指令更加强大，支持各种显示终端。less指 令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。

**参数：**

| 参数 |                说明                |
| :--: | :--------------------------------: |
|  -b  |          设置缓冲区的大小          |
|  -e  |      当文件显示结束后自动退出      |
|  -f  |            强制打开文件            |
|  -g  |       只标志最后搜索的关键词       |
|  -i  |         忽略搜索时的大小写         |
|  -m  |         显示阅读进度百分比         |
|  -N  |           显示每行的行号           |
|  -o  |  将输出的内容在指定文件中保存起来  |
|  -Q  |            不使用警告音            |
|  -s  |         显示连续空行为一行         |
|  -S  | 在单行显示较长的内容，而不换行显示 |
|  -x  | 将TAB字符显示为指定个数的空格字符  |

**交互指令：**

|    操作    |                    说明                    |
| :--------: | :----------------------------------------: |
|    空格    |                向下翻动一页                |
| [pagedown] |                向下翻动一页                |
|  [pageup]  |                向上翻动一页                |
|   /字串    | 向下搜索【字串】；n：向下查找；N：向上查找 |
|   ?字串    | 向上搜索【字串】；n：向下查找；N：向上查找 |
|     q      |               离开 less 程序               |

**例子：**

```shell
# 分页查看指定的文件内容
less anaconda-ks.cfg 

# 分页查看指定的文件内容及行号
less -N anaconda-ks.cfg 

# 分页显示指定命令的输出结果
history | less
```

## `echo`

输出字符串或提取后的变量值

echo是用于在终端设备上输出指定字符串或变量提取后值的命令。能够给用户一些简单的提醒信息，也可以将输出的指定字符串内容同管道符一起传递给后续命令作为标准输入信息再来进行二次处理，又或者同输出重定向符一起操作，将信息直接写入到文件中。

如需提取变量值，需在变量名称前加入$符号做提取，变量名称一般均为大写形式。

|  参数   |               说明               |
| :-----: | :------------------------------: |
|   -n    |        不输出结尾的换行符        |
| -e “\a” |            发出警告音            |
| -e “\b” |        删除前面的一个字符        |
| -e “\c” |          结尾不加换行符          |
| -e “\f” | 换行，光标扔停留在原来的坐标位置 |
| -e “\n” |        换行，光标移至行首        |
| -e “\r” |      光标移至行首，但不换行      |
|   -E    | 禁止反斜杠转移，与-e参数功能相反 |

```shell
# 输出指定字符串到终端设备界面
echo LinuxCool

# 输出某个变量值内容
echo $PATH

# 搭配转义符一起使用，输出纯字符串内容
echo \$PATH

# 搭配输出重定向符一起使用，将字符串内容直接写入文件中
echo "Hello World" > Document

# 搭配反引号执行命令，并将执行结果输出
echo `uptime`

# 输出带有换行符的内容
echo -e "First\nSecond\nThird"

# 指定删除字符串中某些字符，随后将内容输出。结果：12456
echo -e "123\b456" 
```

## `head`

显示文件开头的内容，默认为前10行。

|   参数    |           说明           |
| :-------: | :----------------------: |
| -n <数字> |       定义显示行数       |
| -c <数字> | 指定显示头部内容的字符数 |
|    -v     |  总是显示文件名的头信息  |
|    -q     |   不显示文件名的头信息   |

```shell
# 指定显示文件的前5行内容
head -n 5 anaconda-ks.cfg 

# 指定显示文件的前20个字符
head -c 20 anaconda-ks.cfg 
```

## `tail`

用于查看文件尾部内容，默认为后10行。如果指定了多个文件，则会在显示的每个文件内容前面加上文件名来加以区分。

|     参数      |                             说明                             |
| :-----------: | :----------------------------------------------------------: |
|      -c       |             输出文件尾部的N（N为整数）个字节内容             |
|      -f       |                  持续显示文件最新追加的内容                  |
|      -n       |               输出文件的尾部N（N位数字）行内容               |
|    –retry     | 即是在tail命令启动时，文件不可访问或者文件稍后变得不可访问，都始终尝试打开文件。 |
| –pid=<进程号> | 与“-f”选项连用，当指定的进程号的进程终止后，自动退出tail命令 |

```shell
# 指定显示某个文件尾部的后5行内容
tail -n 5 initial-setup-ks.cfg 

# 指定显示某个文件尾部的后15个字节
tail -c 15 initial-setup-ks.cfg 

# 持续刷新显示某个文件尾部的后10行内容
tail -f /var/log/messages

# 显示文件 notes.log 的内容，从第 20 行至文件末尾
tail -n +20 notes.log
```

## `ln`

自于英文单词 link 的缩写，中文译为“链接”，其功能是用于为某个文件在另外一个位置建立同步的链接。

Linux 统中的链接文件有两种形式，一种是硬链接（hard link），另一种是软链接（symbolic link）。

软连接相当于 Windows 系统中的快捷方式文件，原始文件被移动或删除后，软连接文件也将无法使用，而硬链接则是通过将文件的inode属性块进行了复制 ，因此把原始文件移动或删除后，硬链接文件依然可以使用。

| 参数 |                         说明                         |
| :--: | :--------------------------------------------------: |
|  -b  |          为每个已存在的目标文件创建备份文件          |
|  -d  |         此选项允许“root”用户建立目录的硬链接         |
|  -f  |          强制创建链接，即使目标文件已经存在          |
|  -n  |         把指向目录的符号链接视为一个普通文件         |
|  -i  | 交互模式，若目标文件已经存在，则提示用户确认进行覆盖 |
|  -s  |           对源文件建立符号链接，而非硬链接           |
|  -v  |         详细信息模式，输出指令的详细执行过程         |

```shell
# 为指定的源文件创建快捷方式（默认为硬链接形式）
ln anaconda-ks.cfg ana.cfg

# 为指定的源文件创建快捷方式（设定为软连接形式）
ln -s initial-setup-ks.cfg ini.cfg

# 在指定的源文件创建快捷方式，并输出制作的过程信息
ln -v anaconda-ks.cfg ana.cfg
```

## `history`

显示与管理历史命令记录。Linux系统默认会记录用户所执行过的所有命令，可以使用history命令查阅它们，也可以对其记录进行修改和删除操作。

| 参数 | 说明                       |
| ---- | -------------------------- |
| -a   | 写入命令记录               |
| -c   | 清空命令记录               |
| -d   | 删除指定序号的命令记录     |
| -n   | 读取命令记录               |
| -r   | 读取命令记录到缓冲区       |
| -s   | 将指定的命令添加到缓冲区   |
| -w   | 将缓冲区信息写入到历史文件 |

# 时间日期常用命令

## `date`

用来显示或设定系统的日期与时间。

**参数：**

| 参数 | 说明                                      |
| ---- | ----------------------------------------- |
| -d   | 通过字符串显示时间格式，字符串不能是’now’ |
| -s   | 根据字符串设置系统时间                    |
| -u   | 显示目前的格林威治时间                    |
| -r   | 显示文件的上次修改时间                    |

若是不以加号作为开头，则表示要设定时间，而时间格式为 `MMDDhhmm[[CC]YY][.ss]`，其中`MM`为月份，`DD` 为日，`hh `为小时，`mm` 为分钟，`CC `为年份前两位数字，`YY` 为年份后两位数字，`ss `为秒数。

当您不希望出现无意义的 0 时(比如说 1999/03/07)，则可以在标记中插入 `-` 符号，比如说 `date '+%-H:%-M:%-S'` 会把时分秒中无意义的 0 给去掉，像是原本的 08:09:04 会变为 8:9:4。另外，只有取得权限者(比如说 root)才能设定系统时间。

当您以 root 身分更改了系统时间之后，请记得以 `clock -w `来将系统时间写入 CMOS 中，这样下次重新开机时系统时间才会持续保持最新的正确值。

**例子：**

```shell
# 以默认格式输出系统当前的日期与时间信息
date

# 按照“年-月-日”的指定格式输出系统当前的日期信息
date "+%Y-%m-%d"

# 按照“小时:分钟:秒”的指定格式输出系统当前的时间信息
date "%H:%M:%S"
date "+%Y-%m-%d %H:%M:%S"

# 输出昨天日期
date -d "1 day ago" +"%Y-%m-%d"

# 输出 2 秒后的时间
date -d "2 second" +"%Y-%m-%d %H:%M.%S"

# 时间格式转换
date -d "2009-12-12" +"%Y/%m/%d %H:%M.%S"

# 按自己的格式输出
date '+usr_time: $1:%M %P -hey'
```

```shell
# 时间加减操作
date +%Y%m%d                   # 显示年月日
date -d "+1 day" +%Y%m%d       # 显示后一天的日期
date -d "-1 day" +%Y%m%d       # 显示前一天的日期
date -d "-1 month" +%Y%m%d     # 显示上一月的日期
date -d "+1 month" +%Y%m%d     # 显示下一月的日期
date -d "-1 year" +%Y%m%d      # 显示前一年的日期
date -d "+1 year" +%Y%m%d      # 显示下一年的日期
```

```shell
# 定时间
ate -s                         # 设置当前时间，只有root权限才能设置，其他只能查看
date -s 20120523                # 设置成20120523，这样会把具体时间设置成00:00:00
date -s 01:01:01                # 设置具体时间，不会对日期做更改
date -s "01:01:01 2012-05-23"   # 这样可以设置全部时间
date -s "01:01:01 20120523"     # 这样可以设置全部时间
date -s "2012-05-23 01:01:01"   # 这样可以设置全部时间
date -s "20120523 01:01:01"     # 这样可以设置全部时间
```

## `cal`

显示日历。

cal命令的名字来自英语单词 “Calendar”。改命令用来显示当前日历，或者指定日期的公历（公历是现在国际通用的历法，又称格列历，通称阳历。）如只有一个参数，则表示年份(1-9999)，如有两个参数，则表示月份和年份 。

**参数：**

| 参数 | 说明                           |
| ---- | ------------------------------ |
| -l   | 单月分输出日历                 |
| -3   | 显示最近三个月的日历           |
| -s   | 将星期天作为月的第一天         |
| -m   | 将星期一作为月的第一天         |
| -j   | 显示在当年中的第几天（儒略日） |
| -y   | 显示当年的日历                 |

**例子**

```shell
# 显示当前月份的日历
cal

# 显示近期三个月的日历(当前月，上一个月和下一个月)
cal -3  
                                                        
# 显示指定年月的日历，如显示2020年2月的日历
cal 2 2020
```

# 用户管理常用命令

## `useradd`

创建并设置用户信息。

useradd命令来自于英文词组 “User add” 的全拼，其功能是用于创建并设置用户信息。使用 useradd 命令可以自动的完成创建用户的信息、基本组、家目录等工作，并在创建的过程中对用户初始信息进行定制。

已创建的用户则需使用chmod命令修改账户信息，passwd命令修改密码信息。

| 参数 |                             说明                             |
| :--: | :----------------------------------------------------------: |
|  -D  |                     改变新建用户的预设值                     |
|  -c  |                         添加备注文字                         |
|  -d  |                新用户每次登陆时所使用的家目录                |
|  -e  |             用户终止日期，日期的格式为YYYY-MM-DD             |
|  -f  | 用户过期几日后永久停权。当值为0时用户立即被停权，而值为-1时则关闭此功能，预设值为-1 |
|  -g  |                     指定用户对应的用户组                     |
|  -G  |                 定义此用户为多个不同组的成员                 |
|  -m  |                  用户目录不存在时则自动创建                  |
|  -M  |       不建立用户家目录，优先于/etc/login.defs文件设定        |
|  -n  |                 取消建立以用户名称为名的群组                 |
|  -r  |                         建立系统帐号                         |
|  -u  |                          指定用户id                          |

```java
# 创建指定的用户信息
useradd user1

# 创建指定的用户信息，但不创建家目录，亦不让登录系统
useradd -M -s /sbin/nologin user2

# 创建指定的用户信息，并自定义UID值
useradd -u 6688 user3

# 创建指定的用户信息，并追加指定组为该账户的扩展组
useradd -G root user4

# 创建指定的用户信息，并指定过期时间
useradd -e "2023/01/01" user5

# 为新添加的用户指定home目录
useradd -d /home/myd user6
```

## `passwd`

修改用户的密码值。

passwd命令来自于英文单词password的缩写。同时也可以对用户进行锁定等操作，但需要管理员身份才可以执行。

| 参数 |             说明             |
| :--: | :--------------------------: |
|  -d  |         删除已有密码         |
|  -l  | 锁定用户的密码值，不允许修改 |
|  -u  |  解锁用户的密码值，允许修改  |
|  -e  |     下次登陆强制修改密码     |
|  -k  |    用户在期满后能仍能使用    |
|  -S  |         查询密码状态         |

```shell
# 修改当前登录用户的密码值
passwd

# 修改指定用户的密码值
passwd linuxprobe

# 锁定指定用户的密码值，不允许其进行修改
passwd -l linuxprobe

# 解锁指定用户的密码值，允许其进行修改
passwd -u linuxprobe

# 强制指定的用户在下次登陆时必须重置其密码
passwd -e linuxprobe

# 删除指定用户的密码值
passwd -d linuxprobe

# 查看指定用户的密码状态
passwd -S linuxprobe
```

## `su`

切换用户身份。

su命令来自于英文单词 “switch user” 的缩写。管理员切换至任意用户身份而无需密码验证，而普通用户切换至任意用户身份均需密码验证。另外添加单个减号（-）参数为完全的身份变更，不保留任何之前用户的环境变量信息。

|     参数      |                    说明                    |
| :-----------: | :----------------------------------------: |
| 单个减号（-） |                完全身份变更                |
|      -c       |    执行完指定的指令后，即恢复原来的身份    |
|      -f       | 适用于csh与tsch，使shell不用去读取启动文件 |
|      -l       |       改变身份时，也同时变更工作目录       |
|      -m       |        变更身份时，不要变更环境变量        |
|      -s       |             指定要执行的shell              |

```shell
# 变更至指定用户身份
su user1

# 完全变更至指定用户身份
su - user1
```

## `id`

显示用户与用户组信息。

UID是指用户身份的唯一识别号码，相当于人类社会的身份证号码，而GID则指用户组的唯一识别号码，用户仅有一个基本组，但可以有多个扩展组。

| 参数 |               说明               |
| :--: | :------------------------------: |
|  -g  |       显示用户所属群组的ID       |
|  -G  |       显示用户扩展群组的ID       |
|  -n  | 显示用户所属群组或扩展群组的名称 |
|  -r  |            显示实际ID            |
|  -u  |            显示用户ID            |

```shell
# 显示当前用户的身份信息
id

# 显示当前用户的所属群组GID
id -g

# 显示当前用户的身份码UID
id -u

# 查询当前用户的身份信息
id root
uid=0(root) gid=0(root) groups=0(root)

# 查看创建了哪些用户
cat /etc/passwd
```

## `who`

用于显示当前登录用户信息，包含登录的用户名、终端、日期时间、进程等信息，帮助运维人员了解当前系统的登入用户情况。

| 参数 |               说明               |
| :--: | :------------------------------: |
|  -a  |             全面信息             |
|  -b  |         系统最近启动时间         |
|  -d  |            死掉的进程            |
|  -l  |           系统登录进程           |
|  -H  | 带有列标题打印用户名，终端和时间 |
|  -t  |         系统上次锁定时间         |
|  -u  |          已登录用户列表          |

```shell
# 查看当前登录用户信息
who

# 查看当前登录用户信息，并加上标题
who -H

# 查看当前全部的登录全部用户信息
who -H -a

# 查看系统的最近启动时间
who -b
```

## `userdel`

删除用户账户。

userdel命令来自于英文词组“user delete”的缩写。Linux系统中一切都是文件，用户信息被保存到了/etc/passwd、/etc/shadow以及/etc/group文件中，因此使用userdel命令实际就是帮助我们删除了指定用户在上述三个文件中的对应信息。

| 参数 |              说明              |
| :--: | :----------------------------: |
|  -f  |        强制删除用户账号        |
|  -r  | 删除用户主目录及其中的任何文件 |

```shell
# 删除指定的用户账户信息
userdel linuxcool

# 删除指定的用户账户信息及家目录
userdel -r linuxcool
```

## `sudo`

授权普通用户执行管理员命令。

sudo 命令来自于英文词组 “super user do” 的缩写，中文译为“超级用户才能干的事”。使用sudo服务可以授权某个指定的用户去执行某些指定的命令，在满足工作需求的前提下尽可能少的放权，保证服务器的安全。

配置sudo服务可以直接编辑配置文件/etc/sudoers，亦可以执行visudo命令进行设置，一切妥当后普通用户便能够使用sudo命令进行操作了。

| 参数 |            说明            |
| :--: | :------------------------: |
|  -v  | 本次需要验证当前用户的密码 |
|  -k  | 下次强制验证当前用户的密码 |
|  -b  | 将要执行的指令放在后台执行 |
|  -p  | 更改需要密码验证时的提示语 |
|  -s  | 指定默认调用的SHELL解释器  |

```shell
# 查看当前用户有哪些被sudo服务授权的命令
sudo -l

# 使用某个被sudo服务允许的用户身份来执行管理员的重启命令
sudo -u linuxprobe "reboot"

# 使用当前用户身份，基于sudo命令来执行管理员的重启命令
sudo reboot

# 以root权限执行上一条命令
$ sudo !!
```

## `usermod`

修改用户账号信息。

usermod命令来自于英文词组“user modify”的缩写，其功能是用于修改用户账号中的各项参数。

|     参数     |                说明                |
| :----------: | :--------------------------------: |
|   -c<备注>   |       修改用户账号的备注文字       |
| -d<登入目录> |       修改用户登入时的家目录       |
| -e<有效期限> |         修改账号的有效期限         |
| -f<缓冲天数> | 修改在密码过期后多少天即关闭该账号 |
|   -g<群组>   |         修改用户所属的群组         |
|   -G<群组>   |       修改用户所属的附加群组       |
| -l<账号名称> |          修改用户账号名称          |
|      -L      |      锁定用户密码，使密码无效      |
|      -s      |    修改用户登入后所使用的shell     |
|      -u      |             修改用户ID             |
|      -U      |            解除密码锁定            |

```shell
修改指定用户的家目录路径
usermod -d /home user1

修改指定用户的UID号码
usermod -u 6688 user1

修改指定用户的名称为user2
usermod -l user2 user1

锁定指定用户的账户，临时不允许登录系统
usermod -L user1

解锁指定用户的账户，再次允许登录系统
usermod -U user1
```

# 用户组管理常用命令

## `groupadd`

创建新的用户组。

groupadd命令来自于英文词组“group add”。每个用户在创建时都有一个与其同名的基本组，后期可以使用groupadd命令创建出新的用户组信息，让多个用户加入到指定的扩展组中。

| 参数 |             说明              |
| :--: | :---------------------------: |
|  -g  |      指定新建工作组的id       |
|  -r  |        创建系统工作组         |
|  -K  | 覆盖配置文件“/ect/login.defs” |
|  -o  | 允许添加组ID号不唯一的工作组  |

```shell
# 创建一个新的用户组
groupadd user1

# 创建一个新的用户组，并指定GID号码
groupadd -g 6688 user1

# 创建一个新的用户组，设定为系统工作组
groupadd -r user1
```

## `groupdel`

删除用户组。

groupdel命令用于删除指定的工作组，本命令要修改的系统文件包括/ect/group和/ect/gshadow。

userdel修改系统账户文件，删除与 GROUP 相关的所有项目。给出的组名必须存在。若该群组中仍包括某些用户，则必须先删除这些用户后，方能删除群组。

```shell
# 使用groupdel命令删除user1工作组
groupdel user1

# 查看user1组是否删除成功
more /etc/group|grep user1 
```

## `groupmod`

更改群组识别码或名称。

用户名不要随意修改，组名和 GID 也不要随意修改，因为非常容易导致管理员逻辑混乱。如果非要修改用户名或组名，则建议先删除旧的，再建立新的。

| 参数 | 说明                   |
| ---- | ---------------------- |
| -g   | 设置欲使用的群组识别码 |
| -o   | 重复使用群组识别码     |
| -n   | 设置欲使用的群组名称   |

```shell
# 更改user1用户组为root
groupmod -n root user1
```

# 文件权限

## 文件基本属性

![](http://qiniu.zhouhongyin.top/2023/10/03/1696328093-image-20231003181453891.png)

 Linux 系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。

为了保护系统的安全性，Linux 系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。

在 Linux 中我们可以使用 `ll `或者` ls –l` 命令来显示一个文件的属性以及文件所属的用户和组。

在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等。

- 若是 d 则是目录；
- 若是 - 则是文件；
- 若是 l 则表示为链接文档(link file)；
-  若是 b 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；
- 若是 c 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。

接下来的字符中，以三个为一组，且均为`rwx`的三个参数的组合。其中， `r `代表可读(read)、 `w `代表可写(write)、 `x `代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 `- `而已。

每个文件的属性由左边第一部分的 10 个字符来确定。

![](https://img-blog.csdnimg.cn/753075efdfbe4549adb3b353523c08b8.png)

-  第 0 位确定文件类型，第 1-3 位确定属主（该文件的所有者）拥有该文件的权限。
-  第4-6位确定属组（所有者的同组用户）拥有该文件的权限。
-  第7-9位确定其他用户拥有该文件的权限。
-  第 1、4、7 位表示读权限，如果用 r 字符表示，则有读权限，如果用 - 字符表示，则没有读权限。
-  第 2、5、8 位表示写权限，如果用 w 字符表示，则有写权限，如果用 - 字符表示没有写权限。
-  第 3、6、9 位表示可执行权限，如果用 x 字符表示，则有执行权限，如果用 - 字符表示，则没有执行权限

## 常用命令

### `chmod`

改变文件或目录权限。

chmod命令来自于英文词组 ”change mode“ 的缩写。默认只有文件的所有者和管理员可以设置文件权限，普通用户只能管理自己文件的权限属性。

设置权限时可以使用数字法，亦可使用字母表达式，对于目录文件建议加入-R参数进行递归操作，意味着不仅对于目录本身，也对目录内的子文件/目录都进行新权限的设定。

Linux/Unix 的文件调用权限分为三级 : `文件所有者（Owner）`、`用户组（Group）`、`其它用户（Other Users）`。

![](https://img-blog.csdnimg.cn/cb3b2acfadf54b23bf6c35055fe45a58.png)

只有文件所有者和超级用户可以修改文件或目录的权限。可以使用绝对模式（八进制数字模式），符号模式指定文件的权限。

![](https://img-blog.csdnimg.cn/1790487a98b34ebfa1d572a102ff69b2.png)

**语法：** `chmod [ {ugoa} {+-=} {rwx} ] 文件或目录`

**语法：** `chmod [ mode=421 ] 文件或目录`

`u` 表示该文件的拥有者，`g `表示与该文件的拥有者属于同一个群体(group)者，`o `表示其他以外的人，`a `表示这三者皆是。

`+` 表示增加权限、`- `表示取消权限、`=` 表示唯一设定权限。

`r `表示可读取，`w `表示可写入，`x `表示可执行，`X `表示只有当该文件是个子目录或者该文件已经被设定过为可执行。

| 参数 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| -c   | 若该文件权限确实已经更改，才显示其更改动作                   |
| -f   | 若该文件权限无法被更改也不显示错误讯息                       |
| -v   | 显示权限变更的详细资料                                       |
| -R   | 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更) |

**chmod命令可以使用八进制数来指定权限**

文件或目录的权限位是由9个权限位来控制，每三位为一组，它们分别是文件所有者（User）的读、写、执行，用户组（Group）的读、写、执行以及其它用户（Other）的读、写、执行。

文件权限被放在一个比特掩码中，掩码中指定的比特位设为1，用来说明一个类具有相应的优先级。

| #    | 权限           | rwx   | 二进制 |
| ---- | -------------- | ----- | ------ |
| 7    | 读 + 写 + 执行 | r w x | 111    |
| 6    | 读 + 写        | r w - | 110    |
| 5    | 读 + 执行      | r - x | 101    |
| 4    | 只读           | r - - | 100    |
| 3    | 写 + 执行      | - w x | 011    |
| 2    | 只写           | - w - | 010    |
| 1    | 只执行         | - - x | 001    |
| 0    | 无             | - - - | 000    |

> **例：765 解释：**
>
> - 所有者的权限用数字表达：属主的那三个权限位的数字加起来的总和。如 rwx ，也就是 4+2+1 ，应该是 7。
> - 用户组的权限用数字表达：属组的那个权限位数字的相加的总和。如 rw- ，也就是 4+2+0 ，应该是 6。
> - 其它用户的权限数字表达：其它用户权限位的数字相加的总和。如 r-x ，也就是 4+0+1 ，应该是 5。

```shell
# 设定某个文件的权限为775
chmod 775 anaconda-ks.cfg

# 设定某个文件让任何人都可以读取
chmod a+r anaconda-ks.cfg 

# 设定某个目录及其内子文件任何人都可以读取和读取
chmod -R a+r Documents

# 设定某个二进制命令文件上新增SUID特殊权限位
chmod u+s /sbin/reboot 

# 将文件 file1.txt 设为所有人皆可读取
chmod ugo+r file1.txt

# 将文件 file1.txt 设为所有人皆可读取
chmod a+r file1.txt

# 将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入
chmod ug+w,o-w file1.txt file2.txt

# 为 ex1.py 文件拥有者增加可执行权限
chmod u+x ex1.py

# 将目前目录下的所有文件与子目录皆设为任何人可读取
chmod -R a+r *

# 此外chmod也可以用数字来表示权限如
chmod 777 file
```

### `chown`

改变文件或目录的用户和用户组信息。

chown命令来自于英文词组”Change owner“的缩写。管理员可以改变一切文件的所属信息，而普通用户只能改变自己文件的所属信息。

🔦 **语法格式：** `chown [参数] 所属主:所属组 文件`

| 参数 | 说明                                       |
| ---- | ------------------------------------------ |
| -R   | 对目前目录下的所有文件与目录进行相同的变更 |
| -c   | 显示所属信息变更信息                       |
| -f   | 若该文件拥有者无法被更改也不要显示错误     |
| -h   | 只对于链接文件进行变更，而非真正指向的文件 |
| -v   | 显示拥有者变更的详细资料                   |

```shell
# 改变指定文件的所属主与所属组
chown root:root /etc/fstab

# 改变指定文件的所属主与所属组，并显示过程
chown -c linuxprobe:linuxprobe /etc/fstab

# 改变指定目录及其内所有子文件的所属主与所属组
chown -R root:root /etc

# 把 /var/run/httpd.pid 的所有者设置 root
chown root /var/run/httpd.pid

# 将文件 file1.txt 的拥有者设为 runoob，群体的使用者 runoobgroup
chown runoob:runoobgroup file1.txt

# 将当前前目录下的所有文件与子目录的拥有者皆设为 runoob，群体的使用者 runoobgroup
chown -R runoob:runoobgroup *

# 把 /home/runoob 的关联组设置为 512 （关联组ID），不改变所有者
chown :512 /home/runoob
```

### `chgrp`

更改文件用户组。

chgrp是英语单词“change group”的缩写，命令的作用和其中文释义一样，为用于变更文件或目录的所属群组。

| 参数       | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| -c         | 效果类似”-v”参数，但仅回报更改的部分                         |
| -f         | 不显示错误信息                                               |
| -h         | 对符号连接的文件作修改，而不更动其他任何相关文件             |
| -R         | 递归处理，将指定目录下的所有文件及子目录一并处理             |
| -v         | 显示指令执行过程                                             |
| –reference | 把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同 |

```shell
# 改变文件的群组属性
chgrp -v linuxcool file

# 根据指定文件改变文件的群组属性
chgrp --reference=file_1 file_2

# 将/usr/linuxcool及其子目录下的所有文件的用户组改为cool
chgrp -R cool /usr/linuxcool
```

# 文件搜索常用命令

## `find`

根据路径和条件搜索指定文件。

find命令可以使用的参数很多，并且支持正则表达式，结合管道符后能够实现更加复杂的功能。

find命令通常进行的是从根目录（/）开始的全盘搜索，有别于whereis、which、locate……等等的有条件或部分文件的搜索。对于服务器负载较高的情况，建议不要在高峰时期使用find命令的模糊搜索，会相对消耗较多的系统资源。

| 参数              | 说明                                                         |
| ----------------- | ------------------------------------------------------------ |
| -name             | 匹配名称                                                     |
| -perm             | 匹配权限（mode为完全匹配，-mode为包含即可）                  |
| -user             | 匹配所有者                                                   |
| -group            | 匹配所有组                                                   |
| -mtime -n +n      | 匹配修改内容的时间（-n指n天以内，+n指n天以前）               |
| -atime -n +n      | 匹配访问文件的时间（-n指n天以内，+n指n天以前）               |
| -ctime -n +n      | 匹配修改文件权限的时间（-n指n天以内，+n指n天以前）           |
| -nouser           | 匹配无所有者的文件                                           |
| -nogroup          | 匹配无所有组的文件                                           |
| -newer f1 !f2     | 匹配比文件f1新但比f2旧的文件                                 |
| -type b/d/c/p/l/f | 匹配文件类型（后面的字幕字母依次表示块设备、目录、字符设备、管道、链接文件、文本文件） |
| -size             | 匹配文件的大小（+50KB为查找超过50KB的文件，而-50KB为查找小于50KB的文件） |
| -prune            | 忽略某个目录                                                 |
| -exec …… {};      | 后面可跟用于进一步处理搜索结果的命令                         |

📃参考实例

```shell
# 全盘搜索系统中所有以.conf结尾的文件
find / -name *.conf

# 在/home目录中搜索所有属于指定用户的文件
find /home -user linuxprobe

# 列出当前工作目录中的所有文件、目录以及子文件信息
find .

# 在/var/log目录下搜索所有指定后缀的文件，后缀不需要大小写
find /var/log -iname "*.log"

# 在/var/log目录下搜索所有后缀不是.log的文件
find /var/log ! -name "*.log"

# 搜索当前工作目录中的所有近7天被修改过的文件
find . -mtime +7

# 全盘搜索系统中所有类型为目录，且权限为1777的目录文件
find / -type d -perm 1777

# 全盘搜索系统中所有类型为普通文件，且可以执行的文件信息
find / -type f -perm /a=x 

# 全盘搜索系统中所有后缀为.mp4的文件，并删除所有查找到的文件
find / -name "*.mp4" -exec rm -rf {} \;

# 将当前目录及其子目录下所有文件后缀为 .c 的文件列出来
find . -name "*.c"

# 将当前目录及其子目录中的所有文件列出
find . -type f

# 将当前目录及其子目录下所有最近 20 天内更新过的文件列出
find . -ctime  20

# 查找 /var/log 目录中更改时间在 7 日以前的普通文件，并在删除之前询问它们
find /var/log -type f -mtime +7 -ok rm {} \;

# 查找当前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件
find . -type f -perm 644 -exec ls -l {} \;

# 查找系统中所有文件长度为 0 的普通文件，并列出它们的完整路径
find / -type f -size 0 -exec ls -l {} \;
```

## `grep`

用于查找文件里符合条件的字符串。

grep来自于英文词组 “global search regular expression and print out the line” 的缩写，意思是用于全面搜索的正则表达式，并将结果输出。

通常会将grep命令与正则表达式搭配使用，参数作为搜索过程中的补充或对输出结果的筛选，命令模式十分灵活。

与之容易混淆的是egrep命令和fgrep命令。如果把grep命令当作是标准搜索命令，那么egrep则是扩展搜索命令，等价于“grep -E”命令，支持扩展的正则表达式。而fgrep则是快速搜索命令，等价于“grep -F”命令，不支持正则表达式，直接按照字符串内容进行匹配。

管道符，“|”，表示将前一个命令的处理结果输出传递给后面的命令处理。

> - `ls | grep *.txt`
> - `cat a.txt | grep java `

| 参数 |                            说明                            |
| :--: | :--------------------------------------------------------: |
|  -i  |                         忽略大小写                         |
|  -c  |                     只输出匹配行的数量                     |
|  -l  |         只列出符合匹配的文件名，不列出具体的匹配行         |
|  -n  |                 列出所有的匹配行，显示行号                 |
|  -h  |                  查询多文件时不显示文件名                  |
|  -s  |            不显示不存在、没有匹配文本的错误信息            |
|  -v  |                 显示不包含匹配文本的所有行                 |
|  -w  |                          匹配整词                          |
|  -x  |                          匹配整行                          |
|  -r  |                          递归搜索                          |
|  -q  |        禁止输出任何结果，已退出状态表示搜索是否成功        |
|  -b  |         打印匹配行距文件头部的偏移量，以字节为单位         |
|  -o  | 与-b结合使用，打印匹配的词据文件头部的偏移量，以字节为单位 |
|  -F  |                    匹配固定字符串的内容                    |
|  -E  |                    支持扩展的正则表达式                    |

```shell
# 搜索某个文件中，包含某个关键词的内容
grep root /etc/passwd

# 搜索某个文件中，以某个关键词开头的内容
grep ^root /etc/passwd

# 搜索多个文件中，包含某个关键词的内容
grep linuxprobe /etc/passwd /etc/shadow

# 搜索多个文件中，包含某个关键词的内容，不显示文件名称
grep -h linuxprobe /etc/passwd /etc/shadow

# 输出在某个文件中，包含某个关键词行的数量
grep -c root /etc/passwd /etc/shadow

# 搜索某个文件中，包含某个关键词位置的行号及内容
grep -n network anaconda-ks.cfg 

# 搜索某个文件中，不包含某个关键词的内容
grep -v nologin /etc/passwd

# 搜索当前工作目录中，包含某个关键词内容的文件，未找到则提示
grep -l root *

# 搜索当前工作目录中，包含某个关键词内容的文件，未找到不提示
grep -sl root *

# 递归搜索，不仅搜索指定目录，还搜索其内子目录内是否有关键词文件
grep -srl root /etc

# 搜索某个文件中，精准匹配到某个关键词的内容（搜索词应与整行内容完全一样才会显示，有别于一般搜索）
grep -x cd anaconda-ks.cfg 
grep -x cdrom anaconda-ks.cfg 

# 判断某个文件中，是否包含某个关键词，通过返回状态值输出结果（0为包含，1为不包含），方便在Shell脚本中判断和调用
grep -q linuxprobe anaconda-ks.cfg 
echo $?

grep -q linuxcool anaconda-ks.cfg 
echo $?

# 搜索某个文件中，空行的数量
grep -c ^$ anaconda-ks.cfg 
```

## `which`

查找命令文件。

which 命令能够快速搜索二进制程序所对应的位置。如果我们既不关心同名文件（find与locate），也不关心命令所对应的源代码和帮助文件（whereis），仅仅是想找到命令本身所在的路径，那么就使用which命令。

**参数：**

| 参数 | 说明                       |
| ---- | -------------------------- |
| -n   | 指定文件名长度（不含路径） |
| -p   | 指定文件名长度（含路径）   |
| -w   | 指定输出时栏位的宽度       |
| -V   | 显示版本信息               |

**例子：**

```shell
# 查找某个指定命令文件所在位置
which java

# 查找多个指定命令文件所在位置
which shutdown poweroff
```

## `whereis`

显示命令及相关文件的路径。

whereis 命令用来定位命令的二进制程序、源代码文件和 man 手册页等相关文件的路径。

whereis 命令查找速度非常快，因为它不是在磁盘中乱找，而是在一个数据库中查询;

数据库是 linux 系统自动创建的，包含有本地所有文件的信息，并且每天通过自动执行 updatedb 命令更新一次。

whereis 命令的搜索结果有时候会不准确，比如刚添加的文件可能搜不到， 原因就是该数据库文件没有被更新。

**参数：**

| 参数 | 说明                              |
| ---- | --------------------------------- |
| -b   | 查找二进制程序或命令              |
| -B   | 从指定目录下 查找二进制程序或命令 |
| -m   | 查找man手册文件                   |
| -M   | 从指定目录下 查找man手册文件      |
| -s   | 只查找源代码文件                  |
| -S   | 从指定目录下 查找源代码文件       |
| -f   | 不显示文件名前的路径名称          |
| -u   | 查找不包含指定类型的文件          |

**例子：**

```shell
# 显示ln命令的程序和man手册页的位置
whereis ln

# 显示ln命令的二进制程序的路径
whereis -b ln

# 显示ln命令的man手册页的路径
whereis -m ln
```

# 文件解压缩常用命令

## `gzip`

压缩和解压文件。

gzip 命令来自于英文单词 gunzip 的缩写。gzip是一款使用广泛的压缩工具，文件经过压缩后一般会以 .gz 后缀结尾，与 tar 命令合用后即为 .tar.gz 后缀。

gzip 命令对文本文件的压缩比率通常能达到 60%~70%，压缩后可以很好的提升存储空间的使用率，还能够在网络传输文件时减少等待时间。

|        参数        |                             说明                             |
| :----------------: | :----------------------------------------------------------: |
|         -a         |                      使用ASCII文字模式                       |
|         -d         |                         解开压缩文件                         |
|         -f         |                         强行压缩文件                         |
|         -k         |                          保留原文件                          |
|         -l         |                    列出压缩文件的相关信息                    |
|         -L         |                      显示版本与版权信息                      |
|         -c         |      把压缩后的文件输出到标准输出设备，不去更动原始文件      |
|         -r         |       递归处理，将指定目录下的所有文件及子目录一并处理       |
|         -q         |                        不显示警告信息                        |
|         -n         |          压缩文件时，不保存原来的文件名称及时间戳记          |
|         -N         |           压缩文件时，保存原来的文件名称及时间戳记           |
|         -t         |                   测试压缩文件是否正确无误                   |
| -S<压缩字尾字符串> |                     更改压缩字尾字符串。                     |
|         -v         |                       显示指令执行过程                       |
|         -V         |                         显示版本信息                         |
|    -<压缩效率>     | 压缩效率是一个介于1－9的数值，预设值为"6"，指定愈大的数值，压缩效率就会愈高 |
|       –best        |                此参数的效果和指定"-9"参数相同                |
|       –fast        |                此参数的效果和指定"-1"参数相同                |

```shell
# 将指定的文件进行压缩，压缩包默认会以“原文件名.gz”保存到当前工作目录下，原文件会被自动删除
gzip anaconda-ks.cfg

# 解压指定的压缩包文件，并显示解压过程。解压后的文件会保存在当前工作目录下，压缩包会被自动删除
gzip -dv anaconda-ks.cfg.gz 

# 将指定的文件进行压缩，但是不删除原文件
[root@linuxcool ~]# gzip -k initial-setup-ks.cfg

# 显示指定文件的压缩信息
gzip -l initial-setup-ks.cfg.gz 
```

## `gunzip`

解压提取文件内容。

gunzip 命令来自于英文词组 ”Gnu unzip“ 的缩写。gunzip 通常被用来解压那些被基于 gzip 格式压缩过的文件，也就是那些 .gz 结尾的压缩包。

|        参数        |                             说明                             |
| :----------------: | :----------------------------------------------------------: |
|         -a         |                      使用ASCII文字模式                       |
|         -c         |               把解压后的文件输出到标准输出设备               |
|         -f         | 强行解开压缩文件，不理会文件名称或硬连接是否存在以及该文件是否为符号连接 |
|         -h         |                           在线帮助                           |
|         -l         |                    列出压缩文件的相关信息                    |
|         -L         |                      显示版本与版权信息                      |
|         -n         | 解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其忽略不予处理 |
|         -N         | 解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其回存到解开的文件上 |
|         -q         |                        不显示警告信息                        |
|         -r         |       递归处理，将指定目录下的所有文件及子目录一并处理       |
| -S<压缩字尾字符串> |                      更改压缩字尾字符串                      |
|         -t         |                   测试压缩文件是否正确无误                   |
|         -v         |                       显示指令执行过程                       |
|         -V         |                         显示版本信息                         |

```shell
# 解压指定的压缩包文件
gunzip Filename.gz

# 解压指定的压缩包文件，并输出解压过程
gunzip -v Filename.gz

# 测试指定的压缩包文件内容是否损坏，能够正常解压
gunzip -t Filename.gz
```

## `zip`

压缩文件。

通过 zip 命令可以将文件打包成 .zip 格式的压缩包，里面会附含文件的名称、路径、创建时间、上次修改时间等等信息，与tar命令相似。

|      参数      |                             说明                             |
| :------------: | :----------------------------------------------------------: |
|       -A       |                  调整可执行的自动解压缩文件                  |
|  -b<工作目录>  |                    指定暂时存放文件的目录                    |
|       -c       |                  替每个被压缩的文件加上注释                  |
|       -d       |                  从压缩文件内删除指定的文件                  |
|       -D       |                   压缩文件内不建立目录名称                   |
|       -f       |                        更新现有的文件                        |
|       -F       |                   尝试修复已损坏的压缩文件                   |
|       -g       | 将文件压缩后附加在既有的压缩文件之后，而非另行建立新的压缩文件 |
|  -i<范本样式>  |                     只压缩符合条件的文件                     |
|       -j       |         只保存文件名称及其内容，而不存放任何目录名称         |
|       -J       |                 删除压缩文件前面不必要的数据                 |
|       -L       |                         显示版权信息                         |
|       -m       | 将文件压缩并加入压缩文件后，删除原始文件，即把文件移到压缩文件中 |
| -n<字尾字符串> |                不压缩具有特定字尾字符串的文件                |
|       -o       | 以压缩文件内拥有最新更改时间的文件为准，将压缩文件的更改时间设成和该文件相同 |
|       -q       |                      不显示指令执行过程                      |
|       -r       |       递归处理，将指定目录下的所有文件和子目录一并处理       |
|       -S       |                      包含系统和隐藏文件                      |
|  -t<日期时间>  |                把压缩文件的日期设成指定的日期                |
|       -T       |             检查备份文件内的每个文件是否正确无误             |
|       -u       | 与 -f 参数类似，但是除了更新现有的文件外，也会将压缩文件中的其他文件解压缩到目录中。 |
|       -v       |                显示指令执行过程或显示版本信息                |
|       -w       |    在文件名称里假如版本编号，本参数仅在VMS操作系统下有效     |
|  -x<范本样式>  |                   压缩时排除符合条件的文件                   |
|       -X       |                     不保存额外的文件属性                     |
|       -y       | 直接保存符号连接，而非该连接所指向的文件，本参数仅在UNIX之类的系统下有效 |
|       -z       |                      替压缩文件加上注释                      |
|       -$       |            保存第一个被压缩文件所在磁盘的卷册名称            |
|  -<压缩效率>   |                 压缩效率是一个介于1-9的数值                  |

```shell
# 将指定目录及其内全部文件都打包成zip格式压缩包文件
zip -r backup1.zip /etc

# 将当前工作目录内所有以.cfg为后缀的文件打包
zip -r backup2.zip *.cfg

# 更新压缩包文件中某个文件
zip -dv backup2.zip anaconda-ks.cfg 

# 将/home/html/ 这个目录下所有文件和文件夹打包为当前目录下的 html.zip
zip -q -r html.zip /home/html

# 如果在我们在 /home/html 目录下，可以执行以下命令
zip -q -r html.zip *

# 从压缩文件 cp.zip 中删除文件 a.c
zip -dv cp.zip a.c
```

## `unzip`

解压缩 zip 格式文件。

unzip命令用于解压缩zip格式文件，虽然Linux系统中更多的使用tar命令进行对压缩包的管理工作，但有时也会收到同Windows系统常用的.zip和.rar格式的压缩包文件。

| 参数 |                             说明                             |
| :--: | :----------------------------------------------------------: |
|  -c  |       将解压缩的结果显示到屏幕上，并对字符做适当的转换       |
|  -f  |                        更新现有的文件                        |
|  -l  |                  显示压缩文件内所包含的文件                  |
|  -p  | 与-c参数类似，会将解压缩的结果显示到屏幕上，但不会执行任何的转换 |
|  -t  |                     检查压缩文件是否正确                     |
|  -v  |                     执行时显示详细的信息                     |
|  -z  |                   仅显示压缩文件的备注文字                   |
|  -a  |                 对文本文件进行必要的字符转换                 |
|  -b  |                  不要对文本文件进行字符转换                  |
|  -C  |                压缩文件中的文件名称区分大小写                |
|  -j  |                不处理压缩文件中原有的目录路径                |
|  -L  |               将压缩文件中的全部文件名改为小写               |
|  -n  |                  解压缩时不要覆盖原有的文件                  |
|  -o  |           不必先询问用户，unzip执行后覆盖原有文件            |
|  -q  |                     执行时不显示任何信息                     |

```shell
# 将压缩包文件解压到当前工作目录中
unzip latest.zip

# 将压缩包文件解压到指定的目录中
unzip latest.zip -d /home

# 测试压缩包文件是否完整，文件有无损坏
unzip -t latest.zip
```

## `tar`

压缩和解压缩文件。

tar 命令能够制作出 Linux 系统中常见的 .tar、.tar.gz、.tar.bz2 等格式的压缩包文件。对于RHEL7、CentOS7版本以后的系统，解压时可以不加压缩格式参数（如z或j），系统能自动进行分析并解压。

|         参数          |                        说明                         |
| :-------------------: | :-------------------------------------------------: |
|          -A           |             新增文件到以存在的备份文件              |
|          -B           |                    设置区块大小                     |
|          -c           |                  建立新的备份文件                   |
|          -C           |   <目录> 仅压缩指定目录里的内容或解压缩到指定目录   |
|          -d           |                   记录文件的差别                    |
|          -x           |                从归档文件中提取文件                 |
|          -t           |                 列出备份文件的内容                  |
|          -z           |  通过gzip指令压缩/解压缩文件，文件名最好为*.tar.gz  |
|          -Z           |            通过compress指令处理备份文件             |
|     -f<备份文件>      |                    指定备份文件                     |
|          -v           |                  显示指令执行过程                   |
|          -r           |              添加文件到已经压缩的文件               |
|          -u           |     添加改变了和现有的文件到已经存在的压缩文件      |
|          -j           | 通过bzip2指令压缩/解压缩文件，文件名最好为*.tar.bz2 |
|          -v           |                    显示操作过程                     |
|          -l           |                  文件系统边界设置                   |
|          -k           |                 保留原有文件不覆盖                  |
|          -m           |                  保留文件不被覆盖                   |
|          -w           |                确认压缩文件的正确性                 |
|          -p           |              保留原来的文件权限与属性               |
|          -P           |    使用文件名的绝对路径，不移除文件名称前的“/”号    |
|     -N <日期格式>     |      只将较指定日期更新的文件保存到备份文件里       |
| – -exclude=<范本样式> |               排除符合范本样式的文件                |
|    – -remove-files    |               归档/压缩之后删除源文件               |



```shell
# 使用gzip压缩格式对某个目录进行打包操作，显示压缩过程，压缩包规范后缀为.tar.gz
tar -czvf backup1.tar.gz /etc

# 使用bzip2压缩格式对某个目录进行打包操作，显示压缩过程，压缩包规范后缀为.tar.bz2
tar -cjvf backup2.tar.bz2 /etc

# 将当前工作目录内所有以.cfg为后缀的文件打包，不进行压缩
tar -cvf backup3.tar *.cfg

# 将当前工作目录内的所有以.cfg为后缀的文件打包，不进行压缩，并删除原始文件
tar -cvf backup4.tar *.cfg --remove-files

# 解压某个压缩包到当前工作目录
tar -xvf backup4.tar 

# 解压某个压缩包到/etc目录
tar -xvf backup4.tar -C /etc

# 查看某个压缩包内文件信息（无需解压）
tar -tvf backup4.tar 
```

# 磁盘常用命令

## `tree`

以树状图形式列出目录内容。

|     参数     |                说明                |
| :----------: | :--------------------------------: |
|      -a      |         显示所有文件和目录         |
|      -C      |              彩色显示              |
|      -d      |           仅显示目录名称           |
|      -D      |          显示文件更改时间          |
|      -f      |       显示完整的相对路径名称       |
|      -g      |        显示文件所属群组名称        |
|      -i      |    不以阶梯状列出文件或目录名称    |
|      -l      |  直接显示连接文件所指向的原始目录  |
|      -n      |    不在文件和目录清单上加上色彩    |
|      -N      |       直接列出文件和目录名称       |
|      -p      |            列出权限标示            |
| -P<范本样式> | 只显示符合范本像是的文件或目录名称 |
|      -s      |         列出文件或目录大小         |
|      -t      |     用文件和目录的更改时间排序     |
|      -u      |     列出文件或目录的拥有者名称     |
|      -x      |    将范围局限在现行的文件系统中    |
|      -L      |              层级显示              |

```shell
# 安装
yum install tree

# 显示当前工作目录下的文件层级情况
tree

# 以文件和目录的更改时间进行排序
tree -t

# 以带有相对路径的形式，显示当前工作目录下的文件层级情况
 tree -f

# 只显示目录的层级关系情况
tree -d
```

## `du`

查看文件或目录的大小。

du命令来自于英文词组“Disk Usage”的缩写。不要将df和du命令混淆，df是用于查看磁盘或分区使用情况的命令，而du命令则是用于按照指定容量单位来查看文件或目录在磁盘中的占用情况。

|         参数          |                   说明                   |
| :-------------------: | :--------------------------------------: |
|          -a           |          显示目录中所有文件大小          |
|          -k           |          以KB为单位显示文件大小          |
|          -m           |          以MB为单位显示文件大小          |
|          -g           |          以GB为单位显示文件大小          |
|          -h           | 以易读方式显示文件大小（human readable） |
|          -s           |                仅显示总计                |
| -exclude=<目录或文件> |           略过指定的目录或文件           |
| –max-depth=<目录层数> |      超过指定层数的目录后，予以忽略      |

```shell
# 以易读的容量格式显示指定目录内各个文件的大小信息
du -h /etc

# 以易读的容量格式显示指定目录内总文件的大小信息
du -sh /etc 

# 显示指定文件的大小信息（默认单位为K）
du anaconda-ks.cfg 

# 当前目录磁盘使用情况
du --max-depth=1 -h ./

# 当前目录磁盘使用情况
du -sh ./
```

## `df`

显示系统上磁盘空间的使用量情况。

df 命令来自于英文词组 ”Disk Free“ 的缩写。df 命令显示的磁盘使用量情况含可用、已有及使用率等信息，默认单位为Kb，建议使用-h参数进行单位换算。

|       参数        |                 说明                 |
| :---------------: | :----------------------------------: |
|        -a         |           显示所有系统文件           |
|    -B <块大小>    |          指定显示时的块大小          |
|        -h         |         以容易阅读的方式显示         |
|        -H         |      以1000字节为换算单位来显示      |
|        -i         |           显示索引字节信息           |
|        -k         |           指定块大小为1KB            |
|        -l         |          只显示本地文件系统          |
| -t <文件系统类型> |       只显示指定类型的文件系统       |
|        -T         |        输出时显示文件系统类型        |
|      – -sync      | 在取得磁盘使用信息前，先执行sync命令 |

```shell
# 带有容量单位的显示系统全部磁盘使用量情况
df -h

# 带有容量单位的显示指定磁盘分区使用量情况
df -h /boot

# 显示系统中所有文件系统格式为xfs的磁盘分区使用量情况
df -t xfs
```

## `free`

显示系统内存使用量情况，包含物理和交换内存的总量、使用量和空闲量情况。

| 参数 |              说明              |
| :--: | :----------------------------: |
|  b   |     以Byte显示内存使用情况     |
|  -k  |   以kb为单位显示内存使用情况   |
|  -m  |   以mb为单位显示内存使用情况   |
|  -g  |   以gb为单位显示内存使用情况   |
|  -s  |          持续显示内存          |
|  -t  |        显示内存使用总合        |
|  -h  | 以易读的单位显示内存使用情况() |

```shell
# 以默认的容量单位显示内存使用量信息
free

# 以MB位单位显示内存使用量信息
free -m

# 以易读的单位显示内存使用量信息
free -h

# 以易读的单位显示内存使用量信息，每个10秒刷新一次
free -hs 10
```

# 进程管理常用命令

## `ps`

显示进程状态。

ps 命令来自于英文词组 ”process status“ 的缩写。使用ps命令可以查看到进程的所有信息，例如进程的号码、发起者、系统资源使用占比（处理器与内存）、运行状态等等。帮助我们及时的发现哪些进程出现”僵死“或”不可中断“等异常情况。经常会与kill命令搭配使用来中断和删除不必要的服务进程，避免服务器的资源浪费。

|        参数        |                       说明                       |
| :----------------: | :----------------------------------------------: |
|         a          |  显示现行终端机下的所有程序，包括其他用户的程序  |
|         -A         |                   显示所有程序                   |
|         c          |     显示每个程序真正的指令名称，而不包含路径     |
|         -d         |    显示所有程序，但不包括阶段作业管理员的程序    |
|         e          |     列出程序时，显示每个程序所使用的环境变量     |
|         -f         |            显示UID,PPIP,C与STIME栏位             |
|         g          |   显示现行终端机下的所有程序，包括所属组的程序   |
|         h          |                   不显示标题列                   |
|         -H         |        显示树状结构，表示程序间的相互关系        |
|         -l         |           采用详细的格式来显示程序状况           |
|         -N         | 显示所有的程序，除了执行ps指令终端机下的程序之外 |
|         r          |         只列出现行终端机正在执行中的程序         |
|         -T         |            显示现行终端机下的所有程序            |
|         u          |          以用户为主的格式来显示程序状况          |
|         v          |          采用虚拟内存的格式显示程序状况          |
|       -w或w        |           采用宽阔的格式来显示程序状况           |
|         x          |          显示所有程序，不以终端机来区分          |
| –cols <每列字符数> |               设置每列的最大字符数               |
| –lines <显示列数>  |                设置显示画面的列数                |

常用命令说明：`ps aux`

![](http://qiniu.zhouhongyin.top/2023/10/04/1696407278-image-20231004161438624.png)

**aux 输出格式 :**`USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND`

- USER: 行程拥有者
- PID: 进程的ID号
- %CPU: 占用的 CPU 的百分比
- %MEM: 占用理内存的百分比
- VSZ: 占用的虚拟内存大小，单位KB
- RSS: 占用理内存的大小，单位KB
- TTY: 改进程是在哪个终端中运行的。对于CentOS来说，tty1是图像化界面，tty2-tty6是本地的字符界面终端。pst/0-255代表虚拟终端
- STAT: 该行程的状态:
  - R: 运行状态
  - D: 无法中断的休眠状态 (通常 IO 的进程)
  - R: 正在执行中
  - S: 静止状态(睡眠状态)
  - s: 包含子进程
  - l: 多线程
  - +: 前台显示
  - T: 暂停执行
  - Z: 不存在但暂时无法消除，僵尸状态
  - W: 没有足够的记忆体分页可分配
  - <: 高优先序的行程
  - N: 低优先序的行程
  - L: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O)
- START: 进程开始时间
- TIME: 执行的时间
- COMMAND:所执行的指令

```shell
# 显示系统中全部的进程信息，含详细信息
ps aux 

# 结合输出重定向，将当前进程信息保留备份至指定文件
ps aux > backup.txt

# 结合管道操作符，将当前系统运行状态中指定进程信息过滤出来
ps -ef | grep ssh

# 结合管道操作符，将当前系统运行状态中指定用户的进程信息过滤出来
ps -u root

# 结合管道操作符与sort命令，依据处理器使用量（第三列）情况降序排序
ps aux | sort -rnk 3

# 结合管道操作符与sort命令，依据内存使用量（第四列）情况降序排序
ps aux | sort -rnk 4

# 显示所有进程信息，连同命令行
ps -ef

# 显示指定用户信息
ps -u root 

# 显示 php 的进程
ps -ef | grep php

# 显示进程信息
ps -A 
```

## `kill`

杀死进程。

Linux 系统中如需结束某个进程，既可以使用如 service 或 systemctl 的管理命令来结束服务，也可以使用 kill 命令直接结束进程信息。如使用kill命令后进程并没有被结束，则可以使用信号 9 进行强制杀死动作。

| 参数 |              说明              |
| :--: | :----------------------------: |
|  -l  |       列出系统支持的信号       |
|  -s  |      指定向进程发送的信号      |
|  -a  | 不限制命令名和进程号的对应关系 |
|  -p  |         不发送任何信号         |

**最常用的信号是：**

- 1 (HUP)：重新加载进程。
- 9 (KILL)：杀死一个进程。
- 15 (TERM)：正常停止一个进程。

```shell
# 列出系统支持的全部信号列表
kill -l

# 结束某个指定的进程（数字为对应的PID值）
kill 1518

# 强制结束某个指定的进程（数字为对应的PID值）
kill -9 1518
```

## `pstree`

以树状图显示进程。

Linux系统中pstree命令的英文全称是“process tree”，树状图将会以 pid (如果有指定) 或是以 init 这个基本行程为根 (root)，如果有指定使用者 id，则树状图会只显示该使用者所拥有的行程。

| 参数 |                           说明                           |
| :--: | :------------------------------------------------------: |
|  -a  | 显示每个程序的完整指令，包含路径，参数或是常驻服务的标示 |
|  -c  |                     不使用精简标示法                     |
|  -G  |               使用VT100终端机的列绘图字符                |
|  -h  |           列出树状图时，特别标明现在执行的程序           |

```shell
# 特别表明在运行的进程
pstree -apnh # 显示进程间的关系

# 同时显示用户名称
pstree -u # 显示用户名称

# 显示当前所有进程的进程号和进程id
pstree -p

# 显示所有进程的所有详细信息，遇到相同的进程名可以压缩显示
pstree  -a
```

## `top`

 实时显示系统运行状态。

top命令的功能是用于实时显示系统运行状态，包含处理器、内存、服务、进程等重要资源信息。

**参数：**

|  参数   |                 说明                 |
| :-----: | :----------------------------------: |
| -d <秒> |          改变显示的更新速度          |
|   -s    |      安全模式，不允许交互式指令      |
|   -i    |      不显示任何闲置或僵死的行程      |
|   -n    | 设定显示的总次数，完成后将会自动退出 |

**交互命令：**

|  操作  |                             说明                             |
| :----: | :----------------------------------------------------------: |
| **k**  |                     终止一个进程（常用）                     |
| **q**  |                       退出程序（常用）                       |
| **s**  | 改变两次刷新之间的延迟时间（单位为s），如果有小数，就换算成ms。输入0值则系统将不断刷新，默认值是5s； f或者F：从当前显示中添加或者删除项目（常用） |
| **m**  |                   切换显示内存信息（常用）                   |
| **t**  |              切换显示进程和CPU状态信息（常用）               |
| **c**  |             切换显示命令名称和完整命令行（常用）             |
| **M**  |               根据驻留内存大小进行排序（常用）               |
| **P**  |            根据CPU使用百分比大小进行排序（常用）             |
|   h    |           显示帮助画面，给出一些简短的命令总结说明           |
|   i    |            忽略闲置和僵死进程，这是一个开关式命令            |
|   r    |                  重新安排一个进程的优先级别                  |
|   S    |                        切换到累计模式                        |
| o或者O |                      改变显示项目的顺序                      |
|   l    |                切换显示平均负载和启动时间信息                |
|   T    |                根据CPU使用百分比大小进行排序                 |
|   e    |                 将当前设置写入~/.toprc文件中                 |

**参数解释：**

![](http://qiniu.zhouhongyin.top/2023/10/04/1696408170-image-20231004162930278.png)

- top - 09:44:56[当前系统时间],
- 16 days[系统已经运行了16天],
- 1 user[个用户当前登录],
- load average: 9.59, 4.75, 1.92[系统负载，即任务队列的平均长度]
- Tasks: 145 total[总进程数],
- 2 running[正在运行的进程数],
- 143 sleeping[睡眠的进程数],
- 0 stopped[停止的进程数],
- 0 zombie[冻结进程数],
- Cpu(s): 99.8%us[用户空间占用CPU百分比],
- 0.1%sy[内核空间占用CPU百分比],
- 0.0%ni[用户进程空间内改变过优先级的进程占用CPU百分比],
- 0.2%id[空闲CPU百分比], 0.0%wa[等待输入输出的CPU时间百分比],
- 0.0%hi[],
- 0.0%st[],
- Mem: 4147888k total[物理内存总量],
- 2493092k used[使用的物理内存总量],
- 1654796k free[空闲内存总量],
- 158188k buffers[用作内核缓存的内存量]
- Swap: 5144568k total[交换区总量],
- 56k used[使用的交换区总量],
- 5144512k free[空闲交换区总量],
- 2013180k cached[缓冲的交换区总量],

**例子：**

```shell
# 以默认格式显示系统运行信息
top

# 以默认格式显示系统运行信息，但提供完整的进程路径及名称
top -c  
  
# 以批处理模式显示程序信息
top -b

# 设定每隔5秒刷新一次信息
top -d 5

# 设定总显示次数为3回，随后自动退出命令
top -n 3

top -H   #直接查看系统中所有进程以及其中线程的运行情况
top -H -p <pid>  #查看特定进程下的线程运行情况（先通过“ps -aux | grep 应用名”获取pid ）

#在ps命令中，“-T”选项可以开启线程查看。下面的命令列出了由进程号为<pid>的进程创建的所有线程。
ps -T -p <pid>
```

## `netstat`

显示网络状态。

netstat命令来自于英文词组”network statistics“的缩写，其功能是用于显示各种网络相关信息，例如网络连接状态、路由表信息、接口状态、NAT、多播成员等等。

| 参数 | 说明                                     |
| ---- | ---------------------------------------- |
| -a   | 显示所有连线中的Socket                   |
| -p   | 显示正在使用Socket的程序识别码和程序名称 |
| -l   | 仅列出在监听的服务状态                   |
| -t   | 显示TCP传输协议的连线状况                |
| -u   | 显示UDP传输协议的连线状况                |
| -i   | 显示网络界面信息表单                     |
| -r   | 显示路由表信息                           |
| -n   | 直接使用IP地址，不通过域名服务器         |

**例子：**

```shell
# 显示系统网络状态中的所有连接信息
netstat -an

# 显示系统网络状态中的UDP连接信息
netstat -nu

# 显示系统网络状态中的UDP连接端口号使用信息
netstat -apu 

# 显示网卡当前状态信息
netstat -i 

# 显示网络路由表状态信息
netstat -r

# 找到某个服务所对应的连接信息
netstat -ap | grep ssh
```

> **网络连接状态详解**
>
> **共有12中可能的状态**，前面11种是按照TCP连接建立的三次握手和TCP连接断开的四次挥手过程来描述的：
>
> 1. LISTEN：首先服务端需要打开一个socket进行监听，状态为 LISTEN，侦听来自远方TCP端口的连接请求 ；
> 2. SYN_SENT：客户端通过应用程序调用connect进行active open，于是客户端tcp发送一个SYN以请求建立一个连接，之后状态置为 SYN_SENT，在发送连接请求后等待匹配的连接请求；
> 3. SYN_RECV：服务端应发出ACK确认客户端的 SYN，同时自己向客户端发送一个SYN，之后状态置为，在收到和发送一个连接请求后等待对连接请求的确认；
> 4. ESTABLISHED：代表一个打开的连接，双方可以进行或已经在数据交互了， 代表一个打开的连接，数据可以传送给用户；
> 5. FIN_WAIT1：主动关闭(active close)端应用程序调用close，于是其TCP发出FIN请求主动关闭连接，之后进入FIN_WAIT1状态， 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；
> 6. CLOSE_WAIT：被动关闭(passive close)端TCP接到FIN后，就发出ACK以回应FIN请求(它的接收也作为文件结束符传递给上层应用程序)，并进入CLOSE_WAIT， 等待从本地用户发来的连接中断请求；
> 7. FIN_WAIT2：主动关闭端接到ACK后，就进入了 FIN-WAIT-2，从远程TCP等待连接中断请求；
> 8. LAST_ACK：被动关闭端一段时间后，接收到文件结束符的应用程 序将调用CLOSE关闭连接，这导致它的TCP也发送一个 FIN,等待对方的ACK.就进入了LAST-ACK，等待原来发向远程TCP的连接中断请求的确认；
> 9. TIME_WAIT:在主动关闭端接收到FIN后，TCP 就发送ACK包，并进入TIME-WAIT状态，等待足够的时间以确保远程TCP接收到连接中断请求的确认；
> 10. CLOSING: 比较少见，等待远程TCP对连接中断的确认；
> 11. CLOSED: 被动关闭端在接受到ACK包后，就进入了closed的状态，连接结束，没有任何连接状态；
> 12. UNKNOWN：未知的Socket状态；
>
> **常见标志位**
>
> - SYN: (同步序列编号,Synchronize Sequence Numbers)该标志仅在三次握手建立TCP连接时有效。表示一个新的TCP连接请求。
> - ACK: (确认编号,Acknowledgement Number)是对TCP请求的确认标志,同时提示对端系统已经成功接收所有数据。
> - FIN: (结束标志,FINish)用来结束一个TCP回话.但对应端口仍处于开放状态,准备接收后续数据。

# 定时常用命令

## `crontab`

管理定时计划任务。

crontab命令来自于英文词组“ cron table” 的缩写。定时计划任务，就计划好的任务，到了时间就会自动执行，在Linux系统中的 crond 是一个定时计划任务服务，用户只要能够按照正确的格式（分、时、日、月、星期、命令）写入到配置文件中，那么就会按照预定的周期时间自动的执行下去，而 crontab 命令则是用于配置的工具名称。

**命令格式：**

```shell
crontab [-u user] file
crontab [-u user] [ -e | -l | -r ]
```

**参数：**

| 参数 |                             说明                             |
| :--: | :----------------------------------------------------------: |
|  -e  |                           编辑任务                           |
|  -l  |                           列出任务                           |
|  -r  |                           删除任务                           |
|  -u  |                         指定用户名字                         |
| file | file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。 |

**例子：**

```shell
# 编辑任务
crontab -e

# 列出任务
crontab -l
```

```shell
# crontab 文件格式
*/1 * * * * date >> /root/shell/corntab/date.txt
*/1 * * * * echo "hello, word" >> /root/shell/corntab/date.txt
```

> **注意：**
>
> - 环境变量：环境变量的值，在crontab 文件中获取不到，所以要注意，可以写脚本
> - 在 crontab 中 `%` 是有特殊含义的，表示换行的意思。如果要用的话必须进行转义 `\%`：`59 1 1-7 4 * test 'date +\%w' -eq 0 && /root/a.sh `
> - 解决Linux下执行脚本报错 ：unexpected EOF while looking for matching ``‘ 和 syntax error: unexpected end of file：https://blog.csdn.net/weixin_46818279/article/details/108001514
>
> 

# 软件包管理常用命令

## `rpm`

RPM软件包管理器。

rpm命令来自于英文词组 ”RedHat Package Manager“ 的缩写，中文译为红帽软件包管理器，其功能是用于在Linux系统下对软件包进行安装、卸载、查询、验证、升级等工作。

**参数：**

| 参数 |                  说明                  |
| :--: | :------------------------------------: |
|  -a  |            查询所有的软件包            |
|  -e  |               卸载软件包               |
|  -f  |      查询文件或命令属于哪个软件包      |
|  -i  |               安装软件包               |
|  -l  |          显示软件包的文件列表          |
|  -p  |          查询指定的rpm软件包           |
|  -q  |               查询软件包               |
|  -h  |          安装软件包时列出标记          |
|  -R  |          显示软件包的依赖关系          |
|  -s  | 显示文件状态，本参数需配合”-l”参数使用 |
|  -U  |               升级软件包               |
|  -v  |            显示命令执行过程            |
| -vv  |          详细显示指令执行过程          |

**例子：**

```shell
# 正常安装软件包
rpm -ivh cockpit-185-2.el8.x86_64.rpm 

# 显示系统已安装过的全部RPM软件包
rpm -qa

# 查询某个软件的安装路径
rpm -ql cockpit

# 卸载某个通过RPM软件包安装的服务
rpm -evh cockpit

# 升级某个软件包
rpm -Uvh cockpit-185-2.el8.x86_64.rpm 
```

## `yum`

基于RPM的软件包管理器。

yum命令来自于英文词组 ”YellowdogUpdater,Modified“ 的缩写，其功能是用于在 Linux 系统中基于 RPM 技术进行软件包的管理工作。yum 术通用于 RHEL、CentOS、Fedora、OpenSUSE 等主流系统，可以让系统管理人员交互式的自动化更新和管理软件包，实现从指定服务器自动下载、更新、删除软件包的工作。

yum软件仓库及命令能够自动处理软件依赖关系，一次性安装所需全部软件，无需繁琐的操作。

**参数：**

|     参数     |                      说明                      |
| :----------: | :--------------------------------------------: |
|      -h      |                  显示帮助信息                  |
|      -y      |            对所有的提问都回答“yes”             |
|      -c      |                  指定配置文件                  |
|      -q      |                    安静模式                    |
|      -v      |                    详细模式                    |
|      -t      |                  检查外部错误                  |
|      -d      |              设置调试等级（0-10）              |
|      -e      |              设置错误等级（0-10）              |
|      -R      |       设置yum处理一个命令的最大等待时间        |
|      -C      | 完全从缓存中运行，而不去下载或者更新任何头文件 |
|   install    |                 安装rpm软件包                  |
|    update    |                 更新rpm软件包                  |
| check-update |         检查是否有可用的更新rpm软件包          |
|    remove    |              删除指定的rpm软件包               |
|     list     |                显示软件包的信息                |
|    search    |                检查软件包的信息                |
|     info     |    显示指定的rpm软件包的描述信息和概要信息     |
|    clean     |               清理yum过期的缓存                |
|    shell     |              进入yum的shell提示符              |
|  resolvedep  |            显示rpm软件包的依赖关系             |
| localinstall |              安装本地的rpm软件包               |
| localupdate  |           显示本地rpm软件包进行更新            |
|   deplist    |          显示rpm软件包的所有依赖关系           |

**例子：**

```shell
# 清理原有的软件仓库信息缓存
yum clean all

# 建立最新的软件仓库信息缓存
yum makecache

# 安装指定的服务及相关软件包
yum install httpd

# 更新指定的服务及相关软件包
yum update httpd

# 卸载指定的服务及相关软件包
yum remove httpd

# 显示可安装的软件包组列表
yum grouplist 

# 显示指定服务的软件信息
yum info httpd
```