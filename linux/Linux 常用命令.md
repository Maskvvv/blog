# VIM 编辑器

VI是Unix操作系统和类Unix操作系统中最通用的文本编辑器。
VIM编辑器是从VI发展出来的一个性能更强大的文本编辑器。可以主动的以字体颜色辨别语法的正确性，方便程序设计。VIM 与VI编辑器完全兼容。

## VIM 工作模式转换

![](http://qiniu.zhouhongyin.top/2023/10/03/1696321693-image-20231003162813127.png)

## 一般模式

刚刚启动 vi/vim，便进入了一般模式(默认模式)。此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。在此模式可以复制黏贴，删除等操作。若想要编辑文本，进入一般模式，按下i，切换到编辑模式。

### 复制粘贴删除

| 命令 |                    说明                    |
| :--: | :----------------------------------------: |
|  yy  |         复制游标所在的那一行(常用)         |
| nyy  |     n 为数字。复制光标所在的向下 n 行      |
| y1G  |      复制游标所在行到第一行的所有数据      |
|  yG  |     复制游标所在行到最后一行的所有数据     |
|  y0  | 复制光标所在的那个字符到该行行首的所有数据 |
|  y$  | 复制光标所在的那个字符到该行行尾的所有数据 |
|  p   |       将已复制的数据在光标下一行贴上       |
|  P   |       将已复制的数据在光标上一行贴上       |
|  dd  |        删除游标所在的那一整行(常用)        |
| ndd  |     n 为数字。删除光标所在的向下 n 行      |
| d1G  |       删除光标所在到第一行的所有数据       |
|  dG  |      删除光标所在到最后一行的所有数据      |
|  d$  |    删除游标所在处，到该行的最后一个字符    |
|  d0  |   删除游标所在处，到该行的最前面一个字符   |
|  x   |        向后删除一个字符，相当于 del        |
|  X   |     向前删除一个字符，相当于backspace      |
|  nx  |      n 为数字，连续向后删除 n 个字符       |

### 撤回

|  命令  |      说明      |
| :----: | :------------: |
|   u    | 复原前一个动作 |
| Ctrl+r | 重做上一个动作 |

### 移动光标

|   命令    |                     说明                     |
| :-------: | :------------------------------------------: |
| n< space> | n 表示数字，光标会向右移动这一行的 n 个字符  |
| 0 或Home  |          移动到这一行的最前面字符处          |
|  $ 或End  |          移动到这一行的最后面字符处          |
|     H     | 光标移动到这个屏幕的最上方那一行的第一个字符 |
|     M     |  光标移动到这个屏幕的中央那一行的第一个字符  |
|     L     | 光标移动到这个屏幕的最下方那一行的第一个字符 |
|     G     |           移动到这个档案的最后一行           |
|    nG     |      n 为数字。移动到这个档案的第 n 行       |
|    gg     |            移动到这个档案的第一行            |
|  h 或 ←   |             光标向左移动一个字符             |
|  j 或 ↓   |             光标向下移动一个字符             |
|  k 或 ↑   |             光标向上移动一个字符             |
|  l 或 →   |             光标向右移动一个字符             |
|  Ctrl+ f  |    屏幕向下移动一页，相当于Page Down按键     |
| Ctrl + b  |     屏幕向上移动一页，相当于Page Up按键      |
|  Ctrl+ d  |               屏幕向下移动半页               |
| Ctrl + u  |               屏幕向上移动半页               |

### 搜索

| 操作 |                        说明                        |
| :--: | :------------------------------------------------: |
|  /n  | n为要搜索的内容。向光标之下寻找一个名称为n的字符串 |
|  ?n  |      向光标之上寻找一个字符串名称为n的字符串       |
|  n   |                重复前一个搜寻的动作                |
|  N   |         与 n 相反，反向进行前一个搜寻动作          |

## 编辑模式

在一般模式之中，只要按下 i, o, a 等字符就可以进入输入模式。在编辑模式当中，左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。这个时候，键盘上除了 Esc 这个按键之外，其他的按键都可以视作为一般的输入按钮。

| 操作 |                             说明                             |
| :--: | :----------------------------------------------------------: |
| i, I | i 为从目前光标所在处输入， I 在目前所在行的第一个非空格符处开始输入 |
| a, A | a 为从目前光标所在的下一个字符处开始输入， A 为从光标所在行的最后一个字符处开始输入 |
| o, O | o 为在目前光标所在的下一行处输入新的一行； O 为在目前光标所在的上一行处输入新的一行 |
| r, R | r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止 |

## 命令模式

在一般模式之中，只要按下 ：或 / 就可以进入命令模式。

|     操作      |                             说明                             |
| :-----------: | :----------------------------------------------------------: |
|      :w       |                             保存                             |
|      :w!      | 若文件属性为只读时，强制写入该档案。不过，能不能写入， 还跟你对该档案的档案权限有关 |
|      :q       |                             退出                             |
|      :q!      |                           强制退出                           |
|      :wq      |                          保存并退出                          |
|    :set nu    |                           显示行号                           |
|   :set nonu   |                           取消行号                           |
|     :noh      |                         取消高亮显示                         |
|  :s/old/new   |              替换当前匹配到的第一个 old 为 new               |
| :s/old/new/g  |               替换当前匹配到所有的 old 为 new                |
|  :%s/old/new  |          替换文档中每一行匹配到的第一个 old 为 new           |
| :%s/old/new/g |              替换文档中匹配到所有的 old 为 new               |

# 系统管理

## `systemctl` 命令

systemctl命令来自于英文词组”system control“的缩写，其功能是用于管理系统服务。从RHEL/CentOS7版本之后初始化进程服务init被替代成了systemd服务，systemd初始化进程服务的管理是通过systemctl命令完成的，从功能上涵盖了之前service、chkconfig、init、setup等多条命令的大部分功能。

### 查看服务的方法

`/usr/lib/systemd/system`

### 命令使用方法

`systemctl start | stop | restart | status 服务名`

|            命令            |        说明        |
| :------------------------: | :----------------: |
|           start            |      启动服务      |
|            stop            |      停止服务      |
|          restart           |      重启服务      |
|           enable           |  使某服务开机自启  |
|          disable           | 关闭某服务开机自启 |
|           status           |    查看服务状态    |
| list -units --type=service | 列举所有已启动服务 |

### 例子

```shell
# 启动指定的服务
systemctl start sshd
# 停止指定的服务
systemctl stop sshd
# 重启指定的服务
systemctl restart sshd
# 查看指定服务的运行状态
systemctl status sshd
# 将指定的服务加入到开机启动项中
systemctl enable sshd
# 将指定的服务从开机启动项中取消
systemctl disable sshd
# 显示系统中所有已启动的服务列表信息
systemctl list-units --type=service
```

# 文件常用命令

## `>` & `>>`

`>` 输出重定向和 `>>` 追加

|        命令         |            说明             |
| :-----------------: | :-------------------------: |
|    ls -l > 文件     | 将列表的内容写入文件a.txt中 |
|   ls -al >> 文件    | 列表的内容追加到文件的末尾  |
|  cat 文件1 > 文件2  |  将文件1的内容覆盖到文件2   |
| echo “内容” >> 文件 |      将内容写入到文件       |

## `pwd`

pwd 命令来自于英文词组”print working directory“的缩写，其功能是用于显示当前工作目录的路径，即显示所在位置的绝对路径。

```shell
# 查看当前工作目录路径
pwd

/root/shell
```

## `cd`

cd 命令来自于英文词组”change directory“的缩写，其功能是用于更改当前所处的工作目录，路径可以是绝对路径，也可以是相对路径，若省略不写则会跳转至当前使用者的家目录。~ 也表示为 home 目录 的意思， . 则是表示目前所在的目录，..则表示目前目录位置的上一层目录。


| 参数 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| -P   | 如果切换的目标目录是一个符号链接，则直接切换到符号链接指向的目标目录 |
| -L   | 如果切换的目标目录是一个符号链接，则直接切换到符号链接名所在的目录 |
| –    | 仅使用”-“选项时，当前目录将被切换到环境变量”OLDPWD”对应值的目录 |
| ~    | 切换至当前用户目录                                           |
| ..   | 切换至当前目录位置的上一级目录                               |

```shell
# 切换当前工作目录至/etc
cd /etc

# 切换至当前用户的家目录：
cd ~

# 进入到上一级所在目录（家目录→根目录）
cd ..

# 返回到上一次所在目录（根目录→家目录）
cd -

# 跳到目前目录的上上两层
cd ../..
```

## `ls`

ls 命令来自于英文单词 list 的缩写，其功能是列举出指定目录下的文件名称及其属性。默认不加参数的情况下，ls命令会列出当前工作目录中的文件信息。

|  参数  |                      说明                       |
| :----: | :---------------------------------------------: |
|   -a   |  显示所有文件及目录 (包括以“.”开头的隐藏文件)   |
|   -l   |       使用长格式列出文件及目录的详细信息        |
|   -r   |    将文件以相反次序显示(默认依英文字母次序)     |
|   -t   |             根据最后的修改时间排序              |
|   -A   | 同 -a ，但不列出 “.” (当前目录) 及 “…” (父目录) |
|   -S   |                根据文件大小排序                 |
|   -R   |               递归列出所有子目录                |
|   -d   |     查看目录的信息，而不是里面子文件的信息      |
|   -i   |             输出文件的inode节点信息             |
|   -m   |            水平列出文件，以逗号间隔             |
|   -X   |                按文件扩展名排序                 |
| –color |             输出信息中带有着色效果              |

```shell
# 输出当前目录中的文件（默认不含隐藏文件）
ls

# 输出当前目录中的文件（含隐藏文件）
ls -a

# 输出文件的长格式，包含属性详情信息
ls -l

# 输出指定目录中的文件列表
ls /etc

# 输出文件名称及inode属性块号码
ls -i

# 搭配通配符一起使用，输出指定目录中所有以sd开头的文件名称
ls /dev/sd*

# 依据文件大小进行排序，输出指定目录中文件属性详情信息
ls -Sl /etc

```

## `mkdir`

来自于英文词组 make directories 的缩写，其功能是用来创建目录文件。

| 参数 | 说明                         |
| ---- | ---------------------------- |
| -p   | 递归创建多级目录             |
| -m   | 建立目录的同时设置目录的权限 |
| -z   | 设置安全上下文               |
| -v   | 显示目录的创建过程           |

```shell
# 在当前工作目录中，建立一个目录文件
mkdir dir1

# 在当前工作目录中，创建一个目录文件并设置700权限，不让除所有主以外任何人读、写、执行它
mkdir -m 700 dir2

# 在当前工作目录中，一次性创建多个目录文件
mkdir dir3 dir4 dir5

# 在系统根目录中，一次性创建多个有嵌套关系的目录文件
mkdir -p /dir1/dir2/dir3/dir4/dir5
```

## `rmdir`

来自于英文词组 remove directory 的缩写，其功能是用于删除空目录文件。

rmdir 命令仅能够删除空内容的目录文件，如需删除非空目录时，则需要使用带有-R参数的rm命令进行操作。而rmdir 命令的-p递归删除操作亦不意味着能删除目录中已有的文件，而是要求每个子目录都必须是空的。

| 参数 |                            说明                            |
| :--: | :--------------------------------------------------------: |
|  -p  | 用递归的方式删除指定的目录路径中的所有父级目录，非空则报错 |
|  -v  |                   显示命令的详细执行过程                   |

```shell
# 删除指定的空目录
rmdir Documents

# 删除指定的空目录，及其内的子空目录
rmdir -p Documents

# 删除指定的空目录，并显示删除的过程
rmdir -v Documents
```

## `rm`

来自于英文单词 remove 的缩写，其功能是用于删除文件或目录，一次可以删除多个文件，或递归删除目录及其内的所有子文件。

| 参数 |           说明           |
| :--: | :----------------------: |
|  -f  |  强制删除（不二次询问）  |
|  -i  | 删除前会询问用户是否操作 |
| -r/R |         递归删除         |
|  -v  |  显示指令的详细执行过程  |

```shell
# 删除某个文件，默认会进行二次确认，敲击y进行确认
rm anaconda-ks.cfg 

# 删除某个文件，强制操作不需要二次确认：
rm -f initial-setup-ks.cfg 

# 删除某个目录及其内的子文件或子目录，一并都强制删除
rm -rf Documents

# 强制删除当前工作目录内的所有以.txt为后缀的文件
rm -f *.txt

# 强制清空服务器系统内的所有文件
rm -rf /*
```

## `cp`

来自于英文单词copy的缩写，用于将一个或多个文件或目录复制到指定位置。

| 参数 |                             说明                             |
| :--: | :----------------------------------------------------------: |
|  -f  |             若目标文件已存在，则会直接覆盖原文件             |
|  -i  |              若目标文件已存在，则会询问是否覆盖              |
|  -p  |                  保留源文件或目录的所有属性                  |
|  -r  |                      递归复制文件和目录                      |
|  -d  | 当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录 |
|  -l  |               对源文件建立硬连接，而非复制文件               |
|  -s  |              对源文件建立符号连接，而非复制文件              |
|  -b  |             覆盖已存在的文件目标前将目标文件备份             |
|  -v  |                 详细显示cp命令执行的操作过程                 |
|  -a  |                       等价于“pdr”选项                        |

```shell
# 在当前工作目录中，将某个文件复制一份，并定义新文件名称
cp anaconda-ks.cfg kickstart.cfg

# 在当前工作目录中，将某个目录复制一份，并定义新目录名称
cp -r Documents Doc

复制某个文件时，保留其原始权限及用户归属信息
cp -a kickstart.cfg ks.cfg

# 将某个文件复制到/etc目录中，并覆盖已有文件，不进行询问
cp -f ks.cfg /etc

# 将多个文件一同复制到/etc目录中，如已有目标文件名称则默认询问是否覆盖
cp anaconda-ks.cfg ks.cfg /etc
```

## `mv`

自于英文单词 move 的缩写，用于对文件进行剪切和重命名。

| 参数 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| -i   | 若存在同名文件，则向用户询问是否覆盖                         |
| -f   | 覆盖已有文件时，不进行任何提示                               |
| -b   | 当文件存在时，覆盖前为其创建一个备份                         |
| -n:  | 不要覆盖任何已存在的文件或目录                               |
| -u   | 当源文件比目标文件新，或者目标文件不存在时，才执行移动此操作 |

```shell
# 在当前工作目录中，对某个文件进行剪切后粘贴（重命名）操作
mv anaconda-ks.cfg ks.cfg

# 将某个文件移动到/etc目录中，保留文件原始名称
mv ks.cfg /etc

# 将某个目录移动到/etc目录中，并定义新的目录名称
mv Documents /etc/docs

# 将/home目录中所有的文件都移动到当前工作目录中，遇到已存在文件则直接覆盖
mv -f /home/* .
```

## `cat`

自于英文单词 concatenate 的缩写，其功能是用于查看文件内容。cat命令适合查看内容较少的、纯文本的文件。

| 参数 |              说明              |
| :--: | :----------------------------: |
|  -n  |     显示行数（空行也编号）     |
|  -s  | 显示行数（多个空行算一个编号） |
|  -b  |     显示行数（空行不编号）     |
|  -E  |      每行结束处显示$符号       |

```shell
# 查看某个文件的内容
cat anaconda-ks.cfg

# 查看某个文件的内容，并显示行号
cat -n anaconda-ks.cfg

# 搭配空设备文件和输出重定向操作符，将某个文件内容清空
cat /dev/null > anaconda-ks.cfg 

# 持续写入文件内容，直到碰到EOF符后才会结束并保存
cat > anaconda-ks.cfg << EOF

# 搭配输出重定向操作符，将光盘设备制作成镜像文件
[root@Demo ~]# cat /dev/cdrom > rhel.iso
[root@Demo ~]# ls rhel.iso  -lh
-rw-r--r--. 1 root root 6.7G May  2 00:43 rhel.iso
[root@Demo ~]# file rhel.iso 
rhel.iso: DOS/MBR boot sector; partition 2 : ID=0xef, start-CHS (0x3ff,254,63), end-CHS (0x3ff,254,63), startsector 23128, 19888 sectors
```

## `more`

用于分页显示文本文件内容。如果文本文件中的内容较多较长，使用 cat 命令读取后则很难看清，这时使用 more命令进行分页查看就更加合适，可以把文本内容一页一页的显示在终端界面上，用户每按一次回车即向下一行，每按一次空格即向下一页，直至看完为止。

|   参数    |                             说明                             |
| :-------: | :----------------------------------------------------------: |
|   -num    |                      指定每屏显示的行数                      |
|    -l     | more在通常情况下把 ^L 当作特殊字符, 遇到这个字符就会暂停,-l选项可以阻止这种特性 |
|    -f     |              计算实际的行数，而非自动换行的行数              |
|    -p     |              先清除屏幕再显示文本文件的剩余内容              |
|    -c     |           与-p相似，不滚屏，先显示内容再清除旧内容           |
|    -s     |                    多个空行压缩成一行显示                    |
|    -u     |                          禁止下划线                          |
| +/pattern | 在每个文档显示前搜寻该字(pattern)，然后从该字串之后开始显示  |
|   +num    |                     从第 num 行开始显示                      |

```shell
# 分页显示指定的文本文件内容
more anaconda-ks.cfg 

# 先进行清屏操作，随后以每次10行内容的格式显示指定的文本文件内容
more -c -10 anaconda-ks.cfg

# 分页显示指定的文本文件内容，遇到连续两行以上空白行的情况，则以一行空白行显示
more -s anaconda-ks.cfg

# 从第10行开始，分页显示指定的文本文件内容
more +10 anaconda-ks.cfg 
```

## `less`

less 指令用来分屏查看文件内容，它的功能与 more指 令类似，但是比 more 指令更加强大，支持各种显示终端。less指 令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。

| 参数 |                说明                |
| :--: | :--------------------------------: |
|  -b  |          设置缓冲区的大小          |
|  -e  |      当文件显示结束后自动退出      |
|  -f  |            强制打开文件            |
|  -g  |       只标志最后搜索的关键词       |
|  -i  |         忽略搜索时的大小写         |
|  -m  |         显示阅读进度百分比         |
|  -N  |           显示每行的行号           |
|  -o  |  将输出的内容在指定文件中保存起来  |
|  -Q  |            不使用警告音            |
|  -s  |         显示连续空行为一行         |
|  -S  | 在单行显示较长的内容，而不换行显示 |
|  -x  | 将TAB字符显示为指定个数的空格字符  |

```shell
# 分页查看指定的文件内容
less anaconda-ks.cfg 

# 分页查看指定的文件内容及行号
less -N anaconda-ks.cfg 

# 分页显示指定命令的输出结果
history | less
```

## `echo`

输出字符串或提取后的变量值

echo是用于在终端设备上输出指定字符串或变量提取后值的命令。能够给用户一些简单的提醒信息，也可以将输出的指定字符串内容同管道符一起传递给后续命令作为标准输入信息再来进行二次处理，又或者同输出重定向符一起操作，将信息直接写入到文件中。

如需提取变量值，需在变量名称前加入$符号做提取，变量名称一般均为大写形式。

|  参数   |               说明               |
| :-----: | :------------------------------: |
|   -n    |        不输出结尾的换行符        |
| -e “\a” |            发出警告音            |
| -e “\b” |        删除前面的一个字符        |
| -e “\c” |          结尾不加换行符          |
| -e “\f” | 换行，光标扔停留在原来的坐标位置 |
| -e “\n” |        换行，光标移至行首        |
| -e “\r” |      光标移至行首，但不换行      |
|   -E    | 禁止反斜杠转移，与-e参数功能相反 |

```shell
# 输出指定字符串到终端设备界面
echo LinuxCool

# 输出某个变量值内容
echo $PATH

# 搭配转义符一起使用，输出纯字符串内容
echo \$PATH

# 搭配输出重定向符一起使用，将字符串内容直接写入文件中
echo "Hello World" > Document

# 搭配反引号执行命令，并将执行结果输出
echo `uptime`

# 输出带有换行符的内容
echo -e "First\nSecond\nThird"

# 指定删除字符串中某些字符，随后将内容输出。结果：12456
echo -e "123\b456" 
```

## `head`

显示文件开头的内容，默认为前10行。

|   参数    |           说明           |
| :-------: | :----------------------: |
| -n <数字> |       定义显示行数       |
| -c <数字> | 指定显示头部内容的字符数 |
|    -v     |  总是显示文件名的头信息  |
|    -q     |   不显示文件名的头信息   |

```shell
# 指定显示文件的前5行内容
head -n 5 anaconda-ks.cfg 

# 指定显示文件的前20个字符
head -c 20 anaconda-ks.cfg 
```

## `tail`

用于查看文件尾部内容，默认为后10行。如果指定了多个文件，则会在显示的每个文件内容前面加上文件名来加以区分。

|     参数      |                             说明                             |
| :-----------: | :----------------------------------------------------------: |
|      -c       |             输出文件尾部的N（N为整数）个字节内容             |
|      -f       |                  持续显示文件最新追加的内容                  |
|      -n       |               输出文件的尾部N（N位数字）行内容               |
|    –retry     | 即是在tail命令启动时，文件不可访问或者文件稍后变得不可访问，都始终尝试打开文件。 |
| –pid=<进程号> | 与“-f”选项连用，当指定的进程号的进程终止后，自动退出tail命令 |

```shell
# 指定显示某个文件尾部的后5行内容
tail -n 5 initial-setup-ks.cfg 

# 指定显示某个文件尾部的后15个字节
tail -c 15 initial-setup-ks.cfg 

# 持续刷新显示某个文件尾部的后10行内容
tail -f /var/log/messages

# 显示文件 notes.log 的内容，从第 20 行至文件末尾
tail -n +20 notes.log
```

## `ln`

自于英文单词 link 的缩写，中文译为“链接”，其功能是用于为某个文件在另外一个位置建立同步的链接。

Linux 统中的链接文件有两种形式，一种是硬链接（hard link），另一种是软链接（symbolic link）。

软连接相当于 Windows 系统中的快捷方式文件，原始文件被移动或删除后，软连接文件也将无法使用，而硬链接则是通过将文件的inode属性块进行了复制 ，因此把原始文件移动或删除后，硬链接文件依然可以使用。

| 参数 |                         说明                         |
| :--: | :--------------------------------------------------: |
|  -b  |          为每个已存在的目标文件创建备份文件          |
|  -d  |         此选项允许“root”用户建立目录的硬链接         |
|  -f  |          强制创建链接，即使目标文件已经存在          |
|  -n  |         把指向目录的符号链接视为一个普通文件         |
|  -i  | 交互模式，若目标文件已经存在，则提示用户确认进行覆盖 |
|  -s  |           对源文件建立符号链接，而非硬链接           |
|  -v  |         详细信息模式，输出指令的详细执行过程         |

```shell
# 为指定的源文件创建快捷方式（默认为硬链接形式）
ln anaconda-ks.cfg ana.cfg

# 为指定的源文件创建快捷方式（设定为软连接形式）
ln -s initial-setup-ks.cfg ini.cfg

# 在指定的源文件创建快捷方式，并输出制作的过程信息
ln -v anaconda-ks.cfg ana.cfg
```

## `history`

显示与管理历史命令记录。Linux系统默认会记录用户所执行过的所有命令，可以使用history命令查阅它们，也可以对其记录进行修改和删除操作。

| 参数 | 说明                       |
| ---- | -------------------------- |
| -a   | 写入命令记录               |
| -c   | 清空命令记录               |
| -d   | 删除指定序号的命令记录     |
| -n   | 读取命令记录               |
| -r   | 读取命令记录到缓冲区       |
| -s   | 将指定的命令添加到缓冲区   |
| -w   | 将缓冲区信息写入到历史文件 |

# 用户管理常用命令

## `useradd`

创建并设置用户信息。

useradd命令来自于英文词组 “User add” 的全拼，其功能是用于创建并设置用户信息。使用 useradd 命令可以自动的完成创建用户的信息、基本组、家目录等工作，并在创建的过程中对用户初始信息进行定制。

已创建的用户则需使用chmod命令修改账户信息，passwd命令修改密码信息。

| 参数 |                             说明                             |
| :--: | :----------------------------------------------------------: |
|  -D  |                     改变新建用户的预设值                     |
|  -c  |                         添加备注文字                         |
|  -d  |                新用户每次登陆时所使用的家目录                |
|  -e  |             用户终止日期，日期的格式为YYYY-MM-DD             |
|  -f  | 用户过期几日后永久停权。当值为0时用户立即被停权，而值为-1时则关闭此功能，预设值为-1 |
|  -g  |                     指定用户对应的用户组                     |
|  -G  |                 定义此用户为多个不同组的成员                 |
|  -m  |                  用户目录不存在时则自动创建                  |
|  -M  |       不建立用户家目录，优先于/etc/login.defs文件设定        |
|  -n  |                 取消建立以用户名称为名的群组                 |
|  -r  |                         建立系统帐号                         |
|  -u  |                          指定用户id                          |

```java
# 创建指定的用户信息
useradd user1

# 创建指定的用户信息，但不创建家目录，亦不让登录系统
useradd -M -s /sbin/nologin user2

# 创建指定的用户信息，并自定义UID值
useradd -u 6688 user3

# 创建指定的用户信息，并追加指定组为该账户的扩展组
useradd -G root user4

# 创建指定的用户信息，并指定过期时间
useradd -e "2023/01/01" user5

# 为新添加的用户指定home目录
useradd -d /home/myd user6
```

## `passwd`

修改用户的密码值。

passwd命令来自于英文单词password的缩写。同时也可以对用户进行锁定等操作，但需要管理员身份才可以执行。

| 参数 |             说明             |
| :--: | :--------------------------: |
|  -d  |         删除已有密码         |
|  -l  | 锁定用户的密码值，不允许修改 |
|  -u  |  解锁用户的密码值，允许修改  |
|  -e  |     下次登陆强制修改密码     |
|  -k  |    用户在期满后能仍能使用    |
|  -S  |         查询密码状态         |

```shell
# 修改当前登录用户的密码值
passwd

# 修改指定用户的密码值
passwd linuxprobe

# 锁定指定用户的密码值，不允许其进行修改
passwd -l linuxprobe

# 解锁指定用户的密码值，允许其进行修改
passwd -u linuxprobe

# 强制指定的用户在下次登陆时必须重置其密码
passwd -e linuxprobe

# 删除指定用户的密码值
passwd -d linuxprobe

# 查看指定用户的密码状态
passwd -S linuxprobe
```

## `su`

切换用户身份。

su命令来自于英文单词 “switch user” 的缩写。管理员切换至任意用户身份而无需密码验证，而普通用户切换至任意用户身份均需密码验证。另外添加单个减号（-）参数为完全的身份变更，不保留任何之前用户的环境变量信息。

|     参数      |                    说明                    |
| :-----------: | :----------------------------------------: |
| 单个减号（-） |                完全身份变更                |
|      -c       |    执行完指定的指令后，即恢复原来的身份    |
|      -f       | 适用于csh与tsch，使shell不用去读取启动文件 |
|      -l       |       改变身份时，也同时变更工作目录       |
|      -m       |        变更身份时，不要变更环境变量        |
|      -s       |             指定要执行的shell              |

```shell
# 变更至指定用户身份
su user1

# 完全变更至指定用户身份
su - user1
```

## `id`

显示用户与用户组信息。

UID是指用户身份的唯一识别号码，相当于人类社会的身份证号码，而GID则指用户组的唯一识别号码，用户仅有一个基本组，但可以有多个扩展组。

| 参数 |               说明               |
| :--: | :------------------------------: |
|  -g  |       显示用户所属群组的ID       |
|  -G  |       显示用户扩展群组的ID       |
|  -n  | 显示用户所属群组或扩展群组的名称 |
|  -r  |            显示实际ID            |
|  -u  |            显示用户ID            |

```shell
# 显示当前用户的身份信息
id

# 显示当前用户的所属群组GID
id -g

# 显示当前用户的身份码UID
id -u

# 查询当前用户的身份信息
id root
uid=0(root) gid=0(root) groups=0(root)

# 查看创建了哪些用户
cat /etc/passwd
```

## `who`

用于显示当前登录用户信息，包含登录的用户名、终端、日期时间、进程等信息，帮助运维人员了解当前系统的登入用户情况。

| 参数 |               说明               |
| :--: | :------------------------------: |
|  -a  |             全面信息             |
|  -b  |         系统最近启动时间         |
|  -d  |            死掉的进程            |
|  -l  |           系统登录进程           |
|  -H  | 带有列标题打印用户名，终端和时间 |
|  -t  |         系统上次锁定时间         |
|  -u  |          已登录用户列表          |

```shell
# 查看当前登录用户信息
who

# 查看当前登录用户信息，并加上标题
who -H

# 查看当前全部的登录全部用户信息
who -H -a

# 查看系统的最近启动时间
who -b
```

## `userdel`

删除用户账户。

userdel命令来自于英文词组“user delete”的缩写。Linux系统中一切都是文件，用户信息被保存到了/etc/passwd、/etc/shadow以及/etc/group文件中，因此使用userdel命令实际就是帮助我们删除了指定用户在上述三个文件中的对应信息。

| 参数 |              说明              |
| :--: | :----------------------------: |
|  -f  |        强制删除用户账号        |
|  -r  | 删除用户主目录及其中的任何文件 |

```shell
# 删除指定的用户账户信息
userdel linuxcool

# 删除指定的用户账户信息及家目录
userdel -r linuxcool
```

## `sudo`

授权普通用户执行管理员命令。

sudo 命令来自于英文词组 “super user do” 的缩写，中文译为“超级用户才能干的事”。使用sudo服务可以授权某个指定的用户去执行某些指定的命令，在满足工作需求的前提下尽可能少的放权，保证服务器的安全。

配置sudo服务可以直接编辑配置文件/etc/sudoers，亦可以执行visudo命令进行设置，一切妥当后普通用户便能够使用sudo命令进行操作了。

| 参数 |            说明            |
| :--: | :------------------------: |
|  -v  | 本次需要验证当前用户的密码 |
|  -k  | 下次强制验证当前用户的密码 |
|  -b  | 将要执行的指令放在后台执行 |
|  -p  | 更改需要密码验证时的提示语 |
|  -s  | 指定默认调用的SHELL解释器  |

```shell
# 查看当前用户有哪些被sudo服务授权的命令
sudo -l

# 使用某个被sudo服务允许的用户身份来执行管理员的重启命令
sudo -u linuxprobe "reboot"

# 使用当前用户身份，基于sudo命令来执行管理员的重启命令
sudo reboot

# 以root权限执行上一条命令
$ sudo !!
```

## `usermod`

修改用户账号信息。

usermod命令来自于英文词组“user modify”的缩写，其功能是用于修改用户账号中的各项参数。

|     参数     |                说明                |
| :----------: | :--------------------------------: |
|   -c<备注>   |       修改用户账号的备注文字       |
| -d<登入目录> |       修改用户登入时的家目录       |
| -e<有效期限> |         修改账号的有效期限         |
| -f<缓冲天数> | 修改在密码过期后多少天即关闭该账号 |
|   -g<群组>   |         修改用户所属的群组         |
|   -G<群组>   |       修改用户所属的附加群组       |
| -l<账号名称> |          修改用户账号名称          |
|      -L      |      锁定用户密码，使密码无效      |
|      -s      |    修改用户登入后所使用的shell     |
|      -u      |             修改用户ID             |
|      -U      |            解除密码锁定            |

```shell
修改指定用户的家目录路径
usermod -d /home user1

修改指定用户的UID号码
usermod -u 6688 user1

修改指定用户的名称为user2
usermod -l user2 user1

锁定指定用户的账户，临时不允许登录系统
usermod -L user1

解锁指定用户的账户，再次允许登录系统
usermod -U user1
```

# 用户组管理常用命令

## `groupadd`

创建新的用户组。

groupadd命令来自于英文词组“group add”。每个用户在创建时都有一个与其同名的基本组，后期可以使用groupadd命令创建出新的用户组信息，让多个用户加入到指定的扩展组中。

| 参数 |             说明              |
| :--: | :---------------------------: |
|  -g  |      指定新建工作组的id       |
|  -r  |        创建系统工作组         |
|  -K  | 覆盖配置文件“/ect/login.defs” |
|  -o  | 允许添加组ID号不唯一的工作组  |

```shell
# 创建一个新的用户组
groupadd user1

# 创建一个新的用户组，并指定GID号码
groupadd -g 6688 user1

# 创建一个新的用户组，设定为系统工作组
groupadd -r user1
```

## `groupdel`

删除用户组。

groupdel命令用于删除指定的工作组，本命令要修改的系统文件包括/ect/group和/ect/gshadow。

userdel修改系统账户文件，删除与 GROUP 相关的所有项目。给出的组名必须存在。若该群组中仍包括某些用户，则必须先删除这些用户后，方能删除群组。

```shell
# 使用groupdel命令删除user1工作组
groupdel user1

# 查看user1组是否删除成功
more /etc/group|grep user1 
```

## `groupmod`

更改群组识别码或名称。

用户名不要随意修改，组名和 GID 也不要随意修改，因为非常容易导致管理员逻辑混乱。如果非要修改用户名或组名，则建议先删除旧的，再建立新的。

| 参数 | 说明                   |
| ---- | ---------------------- |
| -g   | 设置欲使用的群组识别码 |
| -o   | 重复使用群组识别码     |
| -n   | 设置欲使用的群组名称   |

```shell
# 更改user1用户组为root
groupmod -n root user1
```

# 文件权限

## 文件基本属性

![](http://qiniu.zhouhongyin.top/2023/10/03/1696328093-image-20231003181453891.png)

 Linux 系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。

为了保护系统的安全性，Linux 系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。

在 Linux 中我们可以使用 `ll `或者` ls –l` 命令来显示一个文件的属性以及文件所属的用户和组。

在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等。

- 若是 d 则是目录；
- 若是 - 则是文件；
- 若是 l 则表示为链接文档(link file)；
-  若是 b 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；
- 若是 c 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。

接下来的字符中，以三个为一组，且均为`rwx`的三个参数的组合。其中， `r `代表可读(read)、 `w `代表可写(write)、 `x `代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 `- `而已。

每个文件的属性由左边第一部分的 10 个字符来确定。

![](https://img-blog.csdnimg.cn/753075efdfbe4549adb3b353523c08b8.png)

-  第 0 位确定文件类型，第 1-3 位确定属主（该文件的所有者）拥有该文件的权限。
-  第4-6位确定属组（所有者的同组用户）拥有该文件的权限。
-  第7-9位确定其他用户拥有该文件的权限。
-  第 1、4、7 位表示读权限，如果用 r 字符表示，则有读权限，如果用 - 字符表示，则没有读权限。
-  第 2、5、8 位表示写权限，如果用 w 字符表示，则有写权限，如果用 - 字符表示没有写权限。
-  第 3、6、9 位表示可执行权限，如果用 x 字符表示，则有执行权限，如果用 - 字符表示，则没有执行权限

## 常用命令

### `chmod`

改变文件或目录权限。

chmod命令来自于英文词组 ”change mode“ 的缩写。默认只有文件的所有者和管理员可以设置文件权限，普通用户只能管理自己文件的权限属性。

设置权限时可以使用数字法，亦可使用字母表达式，对于目录文件建议加入-R参数进行递归操作，意味着不仅对于目录本身，也对目录内的子文件/目录都进行新权限的设定。

Linux/Unix 的文件调用权限分为三级 : `文件所有者（Owner）`、`用户组（Group）`、`其它用户（Other Users）`。

![](https://img-blog.csdnimg.cn/cb3b2acfadf54b23bf6c35055fe45a58.png)

只有文件所有者和超级用户可以修改文件或目录的权限。可以使用绝对模式（八进制数字模式），符号模式指定文件的权限。

![](https://img-blog.csdnimg.cn/1790487a98b34ebfa1d572a102ff69b2.png)

**语法：** `chmod [ {ugoa} {+-=} {rwx} ] 文件或目录`

**语法：** `chmod [ mode=421 ] 文件或目录`

`u` 表示该文件的拥有者，`g `表示与该文件的拥有者属于同一个群体(group)者，`o `表示其他以外的人，`a `表示这三者皆是。

`+` 表示增加权限、`- `表示取消权限、`=` 表示唯一设定权限。

`r `表示可读取，`w `表示可写入，`x `表示可执行，`X `表示只有当该文件是个子目录或者该文件已经被设定过为可执行。

| 参数 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| -c   | 若该文件权限确实已经更改，才显示其更改动作                   |
| -f   | 若该文件权限无法被更改也不显示错误讯息                       |
| -v   | 显示权限变更的详细资料                                       |
| -R   | 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更) |

**chmod命令可以使用八进制数来指定权限**

文件或目录的权限位是由9个权限位来控制，每三位为一组，它们分别是文件所有者（User）的读、写、执行，用户组（Group）的读、写、执行以及其它用户（Other）的读、写、执行。

文件权限被放在一个比特掩码中，掩码中指定的比特位设为1，用来说明一个类具有相应的优先级。

| #    | 权限           | rwx   | 二进制 |
| ---- | -------------- | ----- | ------ |
| 7    | 读 + 写 + 执行 | r w x | 111    |
| 6    | 读 + 写        | r w - | 110    |
| 5    | 读 + 执行      | r - x | 101    |
| 4    | 只读           | r - - | 100    |
| 3    | 写 + 执行      | - w x | 011    |
| 2    | 只写           | - w - | 010    |
| 1    | 只执行         | - - x | 001    |
| 0    | 无             | - - - | 000    |

> **例：765 解释：**
>
> - 所有者的权限用数字表达：属主的那三个权限位的数字加起来的总和。如 rwx ，也就是 4+2+1 ，应该是 7。
> - 用户组的权限用数字表达：属组的那个权限位数字的相加的总和。如 rw- ，也就是 4+2+0 ，应该是 6。
> - 其它用户的权限数字表达：其它用户权限位的数字相加的总和。如 r-x ，也就是 4+0+1 ，应该是 5。

```shell
# 设定某个文件的权限为775
chmod 775 anaconda-ks.cfg

# 设定某个文件让任何人都可以读取
chmod a+r anaconda-ks.cfg 

# 设定某个目录及其内子文件任何人都可以读取和读取
chmod -R a+r Documents

# 设定某个二进制命令文件上新增SUID特殊权限位
chmod u+s /sbin/reboot 

# 将文件 file1.txt 设为所有人皆可读取
chmod ugo+r file1.txt

# 将文件 file1.txt 设为所有人皆可读取
chmod a+r file1.txt

# 将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入
chmod ug+w,o-w file1.txt file2.txt

# 为 ex1.py 文件拥有者增加可执行权限
chmod u+x ex1.py

# 将目前目录下的所有文件与子目录皆设为任何人可读取
chmod -R a+r *

# 此外chmod也可以用数字来表示权限如
chmod 777 file
```

### `chown`

改变文件或目录的用户和用户组信息。

chown命令来自于英文词组”Change owner“的缩写。管理员可以改变一切文件的所属信息，而普通用户只能改变自己文件的所属信息。

🔦 **语法格式：** `chown [参数] 所属主:所属组 文件`

| 参数 | 说明                                       |
| ---- | ------------------------------------------ |
| -R   | 对目前目录下的所有文件与目录进行相同的变更 |
| -c   | 显示所属信息变更信息                       |
| -f   | 若该文件拥有者无法被更改也不要显示错误     |
| -h   | 只对于链接文件进行变更，而非真正指向的文件 |
| -v   | 显示拥有者变更的详细资料                   |

```shell
# 改变指定文件的所属主与所属组
chown root:root /etc/fstab

# 改变指定文件的所属主与所属组，并显示过程
chown -c linuxprobe:linuxprobe /etc/fstab

# 改变指定目录及其内所有子文件的所属主与所属组
chown -R root:root /etc

# 把 /var/run/httpd.pid 的所有者设置 root
chown root /var/run/httpd.pid

# 将文件 file1.txt 的拥有者设为 runoob，群体的使用者 runoobgroup
chown runoob:runoobgroup file1.txt

# 将当前前目录下的所有文件与子目录的拥有者皆设为 runoob，群体的使用者 runoobgroup
chown -R runoob:runoobgroup *

# 把 /home/runoob 的关联组设置为 512 （关联组ID），不改变所有者
chown :512 /home/runoob
```

### `chgrp`

更改文件用户组。

chgrp是英语单词“change group”的缩写，命令的作用和其中文释义一样，为用于变更文件或目录的所属群组。

| 参数       | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| -c         | 效果类似”-v”参数，但仅回报更改的部分                         |
| -f         | 不显示错误信息                                               |
| -h         | 对符号连接的文件作修改，而不更动其他任何相关文件             |
| -R         | 递归处理，将指定目录下的所有文件及子目录一并处理             |
| -v         | 显示指令执行过程                                             |
| –reference | 把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同 |

```shell
# 改变文件的群组属性
chgrp -v linuxcool file

# 根据指定文件改变文件的群组属性
chgrp --reference=file_1 file_2

# 将/usr/linuxcool及其子目录下的所有文件的用户组改为cool
chgrp -R cool /usr/linuxcool
```

# 文件搜索常用命令

## `find`

根据路径和条件搜索指定文件。

find命令可以使用的参数很多，并且支持正则表达式，结合管道符后能够实现更加复杂的功能。

find命令通常进行的是从根目录（/）开始的全盘搜索，有别于whereis、which、locate……等等的有条件或部分文件的搜索。对于服务器负载较高的情况，建议不要在高峰时期使用find命令的模糊搜索，会相对消耗较多的系统资源。

| 参数              | 说明                                                         |
| ----------------- | ------------------------------------------------------------ |
| -name             | 匹配名称                                                     |
| -perm             | 匹配权限（mode为完全匹配，-mode为包含即可）                  |
| -user             | 匹配所有者                                                   |
| -group            | 匹配所有组                                                   |
| -mtime -n +n      | 匹配修改内容的时间（-n指n天以内，+n指n天以前）               |
| -atime -n +n      | 匹配访问文件的时间（-n指n天以内，+n指n天以前）               |
| -ctime -n +n      | 匹配修改文件权限的时间（-n指n天以内，+n指n天以前）           |
| -nouser           | 匹配无所有者的文件                                           |
| -nogroup          | 匹配无所有组的文件                                           |
| -newer f1 !f2     | 匹配比文件f1新但比f2旧的文件                                 |
| -type b/d/c/p/l/f | 匹配文件类型（后面的字幕字母依次表示块设备、目录、字符设备、管道、链接文件、文本文件） |
| -size             | 匹配文件的大小（+50KB为查找超过50KB的文件，而-50KB为查找小于50KB的文件） |
| -prune            | 忽略某个目录                                                 |
| -exec …… {};      | 后面可跟用于进一步处理搜索结果的命令                         |

📃参考实例

```shell
# 全盘搜索系统中所有以.conf结尾的文件
find / -name *.conf

# 在/home目录中搜索所有属于指定用户的文件
find /home -user linuxprobe

# 列出当前工作目录中的所有文件、目录以及子文件信息
find .

# 在/var/log目录下搜索所有指定后缀的文件，后缀不需要大小写
find /var/log -iname "*.log"

# 在/var/log目录下搜索所有后缀不是.log的文件
find /var/log ! -name "*.log"

# 搜索当前工作目录中的所有近7天被修改过的文件
find . -mtime +7

# 全盘搜索系统中所有类型为目录，且权限为1777的目录文件
find / -type d -perm 1777

# 全盘搜索系统中所有类型为普通文件，且可以执行的文件信息
find / -type f -perm /a=x 

# 全盘搜索系统中所有后缀为.mp4的文件，并删除所有查找到的文件
find / -name "*.mp4" -exec rm -rf {} \;

# 将当前目录及其子目录下所有文件后缀为 .c 的文件列出来
find . -name "*.c"

# 将当前目录及其子目录中的所有文件列出
find . -type f

# 将当前目录及其子目录下所有最近 20 天内更新过的文件列出
find . -ctime  20

# 查找 /var/log 目录中更改时间在 7 日以前的普通文件，并在删除之前询问它们
find /var/log -type f -mtime +7 -ok rm {} \;

# 查找当前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件
find . -type f -perm 644 -exec ls -l {} \;

# 查找系统中所有文件长度为 0 的普通文件，并列出它们的完整路径
find / -type f -size 0 -exec ls -l {} \;
```

## `grep`

用于查找文件里符合条件的字符串。

grep来自于英文词组 “global search regular expression and print out the line” 的缩写，意思是用于全面搜索的正则表达式，并将结果输出。

通常会将grep命令与正则表达式搭配使用，参数作为搜索过程中的补充或对输出结果的筛选，命令模式十分灵活。

与之容易混淆的是egrep命令和fgrep命令。如果把grep命令当作是标准搜索命令，那么egrep则是扩展搜索命令，等价于“grep -E”命令，支持扩展的正则表达式。而fgrep则是快速搜索命令，等价于“grep -F”命令，不支持正则表达式，直接按照字符串内容进行匹配。

管道符，“|”，表示将前一个命令的处理结果输出传递给后面的命令处理。

> - `ls | grep *.txt`
> - `cat a.txt | grep java `

| 参数 |                            说明                            |
| :--: | :--------------------------------------------------------: |
|  -i  |                         忽略大小写                         |
|  -c  |                     只输出匹配行的数量                     |
|  -l  |         只列出符合匹配的文件名，不列出具体的匹配行         |
|  -n  |                 列出所有的匹配行，显示行号                 |
|  -h  |                  查询多文件时不显示文件名                  |
|  -s  |            不显示不存在、没有匹配文本的错误信息            |
|  -v  |                 显示不包含匹配文本的所有行                 |
|  -w  |                          匹配整词                          |
|  -x  |                          匹配整行                          |
|  -r  |                          递归搜索                          |
|  -q  |        禁止输出任何结果，已退出状态表示搜索是否成功        |
|  -b  |         打印匹配行距文件头部的偏移量，以字节为单位         |
|  -o  | 与-b结合使用，打印匹配的词据文件头部的偏移量，以字节为单位 |
|  -F  |                    匹配固定字符串的内容                    |
|  -E  |                    支持扩展的正则表达式                    |

```shell
# 搜索某个文件中，包含某个关键词的内容
grep root /etc/passwd

# 搜索某个文件中，以某个关键词开头的内容
grep ^root /etc/passwd

# 搜索多个文件中，包含某个关键词的内容
grep linuxprobe /etc/passwd /etc/shadow

# 搜索多个文件中，包含某个关键词的内容，不显示文件名称
grep -h linuxprobe /etc/passwd /etc/shadow

# 输出在某个文件中，包含某个关键词行的数量
grep -c root /etc/passwd /etc/shadow

# 搜索某个文件中，包含某个关键词位置的行号及内容
grep -n network anaconda-ks.cfg 

# 搜索某个文件中，不包含某个关键词的内容
grep -v nologin /etc/passwd

# 搜索当前工作目录中，包含某个关键词内容的文件，未找到则提示
grep -l root *

# 搜索当前工作目录中，包含某个关键词内容的文件，未找到不提示
grep -sl root *

# 递归搜索，不仅搜索指定目录，还搜索其内子目录内是否有关键词文件
grep -srl root /etc

# 搜索某个文件中，精准匹配到某个关键词的内容（搜索词应与整行内容完全一样才会显示，有别于一般搜索）
grep -x cd anaconda-ks.cfg 
grep -x cdrom anaconda-ks.cfg 

# 判断某个文件中，是否包含某个关键词，通过返回状态值输出结果（0为包含，1为不包含），方便在Shell脚本中判断和调用
grep -q linuxprobe anaconda-ks.cfg 
echo $?

grep -q linuxcool anaconda-ks.cfg 
echo $?

# 搜索某个文件中，空行的数量
grep -c ^$ anaconda-ks.cfg 
```