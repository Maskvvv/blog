---
title: Java面试题（三）
date: 2021-6-14
updated: 2021-6-14
tags:
  - Java
categories:
  - 面试
  - Java面试题（三）
---



![](http://qiniu.zhouhongyin.top/2022/06/12/1655042839-1_iIXOmGDzrtTJmdwbn7cGMw.png)

<!-- more -->

## Java 中的两种异常类型是什么？他们有什么区别？

Throwable 包含了错误（Error）和异常（Exception 两类）

Exception 类又分为运行时异常（Runtime Exception）和受检查的异常（Checked Exception），

(1) Error 类一般是指与虚拟机相关的问题， 如 OutOfMemoryError、stackoverflow 等等，对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防， Java 虚拟机一般会终止线程。

(2) 运行时异常都是 RuntimeException 类及其子类，如 NullPointerException、IndexOutOfBoundsException 等，这些异常是不检查的异常，是在程序运行的时候可能会发生的，所以程序可以捕捉，也可以不捕捉，这些错误一般是由程序的逻辑错误引起的，程序应该从逻辑角度去尽量避免。

(3) 检查异常是运行时异常以外的异常，也是 Exception 及其子类，这些异常从程序的角度来说是要么用 try catch 捕获，要么用 throws 字句声明抛出，交给它的父类处理，否则不能通过编译，如 IOException、SQLException 等。

## throw 和 throws 有什么区别？

**区别：**

1. Throw 用于方法内部，Throws 用于方法声明上
2. Throw 后跟异常对象，Throws 后跟异常类型
3. Throw 后只能跟一个异常对象，Throws 后可以一次声明多种异常类型

**语法：**

- throw (异常对象)
  - `throw e;`
- 修饰符 返回值类型 方法名  参数类型  throws异常类
  - `public void test(int a) throws Exception1,Exception2{}`

## 异常处理完成以后，Exception 对象会发生什么变化？

 异常处理对象在异常处理完后，没有引用指向它，变成了不可达对象.  

它将在接下来 JVM 进行 gc 操作时被标记为"不可达"，如果该 Exception 实例实现了 finalize 方法，那么就会安排到 F-queue 队列中等待执行 finalize 方法,但是由于 F-queue 所在线程的优先级很低，所以可能一直得不到执行，而长时间留在该队列中。

再下一次执行 gc 时，如果 Exception 对象已经执行完成 finalize 方法，它将被回收(彻底抹去内存中的数据)。

## finally 代码块和 finalize() 方法有什么区别？

1. final 是关键字，final 可以修饰**类、方法、属性**。
   - 如果一个**类被 final 修饰**，那么这个类就是**最终类**，**不能派生出新的子类**，**不能作为父类被继承**，该类中的**所有方法都不能被重写**，但是 final 类中的**成员变量是可以改变**的，要想 final 类中的成员变量的不可以改变，必须给成员变量添加 final 修饰。因此，一个类**不能同时被 final 和 abstract 修饰**，这两个关键字相互矛盾。
   - 如果 **final 修饰方法**，那么这个方法是最终方法，不**允许任何子类重写该方法**，但子类仍**可以使用该方法**，注意：final 参数用来表示这个参数在这个函数内部不允许被修改。 
   - **final 修饰属性**，被 final 修饰的变量不可变。这里的不可变有两重含义：**引用不可变和对象不可变。**final 指的是引用不可变，**即它只能指向初始化时指向的那个对象，而不关心指向对象内容的变化**。因此，被 **final 修饰的变量必须初始化**，该变量其实就是常量。
2. finally 作为**异常处理的一部分**，只能用在 try/catch 语句块中，**finally 代码块中的语句一定会被执行**，经常被用来释放资源，如 IO 流和数据库资源的释放。 
3. finalize 是 Object 类的一个方法，该方法在 Object 类中声明：`protected void finalize() throws Throwable { }`在垃圾回收器执行时会调用被回收对象的 finalize() 方法，可以覆盖此方法来实现对其资源的回收。注意：一旦垃圾回收器准备释放某个对象占用的空间，将首先调该对象的 finalize() 方法，并且在下一次垃圾回收动作发生时，才真正将该对象占用的内存回收。

## 什么是 JDBC？

**答案一：**

JDBC（Java DataBase  Connectivity），是一套面向对象的应用程序接口（API），制定了统一的访问各类关系数据库的标准接口，为各个数据库厂商提供了标准的实现。通过 JDBC 技术，开发人员可以用纯 Java 语言和标准的 SQL 语句编写完整的数据库应用程序，并且真正地实现了软件的跨平台性。

**通常情况下使用JDBC完成以下操作：**

1. 同数据库建立连接；

2. 向数据库发送 SQL 语句；

3. 处理从数据库返回的结果；

  **JDBC具有下列优点：**

1. JDBC与 ODBC (Open Database Connectivity，即开放数据库互连）十分相似，便于软件开发人员理解；

2. JDBC 使软件开发人员从复杂的驱动程序编写工作中解脱出来，可以完全专注于业务逻辑开发；

3. JDBC 支持多种关系型数据库，大大增加了软件的可移植性；

4. JDBC API 是面向对象的，软件开发人员可以将常用的方法进行二次封装，从而提高代码的重用性；

**答案二：**

JDBC：提供不同数据库进行统一访问的工具，使开发者可以直接使用 Java 写数据库程序，而无需关心具体数据库的细节。 

跟 JVM 很相似：都是提供了统一的方式来完成跨平台的使用，至于平台的不同，由平台自身完成

## 解释下驱动(Driver)在JDBC中的角色。

JDBC是一套规范(通俗的说就是一套接口),它本身是没有针对具体数据库操作提供实现的, 所以谁要让自家的数据库适配JDBC,就实现这套接口即可. 

一般叫实现 JDBC 规范的 jar 包为 JDBC 驱动（我们通过 JDBC 接口执行数据库操作命令，具体操作数据库的是驱动程序）。

## Class.forName() 方法有什么作用？

初始化参数指定的类，并且返回此类对应的 Class 对象

在初始化一个类，生成一个实例的时候，newInstance() 方法和 new 关键字除了一个是方法，一个是关键字外，它们的区别在于创建对象的方式不一样，前者是使用类加载机制，后者是创建一个新类。 从 JVM 的角度看，我们使用关键字 new 创建一个类的时候，这个类可以没有被加载。但是使用 newInstance() 方法的时候，就必须保证： ① 这个类已经加载；② 这个类已经连接了。 而完成上面两个步骤的正是 Class 的静态方法 forName()所完成的，这个静态方法调用了启动类加载器，即加载 Java API 的那个加载器。

## PreparedStatement 比Statement有什么优势？

1. PreparedStatement 是预编译的，性能会比 Statement 好

2. PreparedStatement 可以防止 sql 注入，安全性比 Statement 高

3. PreparedStatements 可以写动态参数化的查询，提高了代码的可扩展性与可维护性

## 数据库连接池是什么意思？

数据库连接的建立、关闭资源消耗巨大。 

传统数据库访问方式：一次数据访问对应一个物理连接，每次操作数据库都要打开关闭该物理连接，系统性能严重受损。

解决方案：数据库连接池。系统初始运行时，主动建立足够足够的连接，组成一个池，每次应用程序请求数据库连接时，无需重新打开连接，而是从池中取出已有的连接，使用完后，不再关闭，而是归还。

> 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个； 连接池是存储、管理数据库连接的容器，应用程序把获取数据库连接的功能委托给连接池，每个连接池都有一个上限，如果连接池达到上限，应用程序线程申请连接时被堵塞，等待其他线程释放连接，每个线程使用完连接后并不马上关闭，至少把它返还给连接池。由于连接的共享，不会频繁的创建、销毁连接，因此就不会增加创建连接的开销，也不会出现 socket 释放延迟现象。

## 什么是 RMI？

**答案一：**

Java RMI（Remote Method Invocation）—— Java 的远程方法调用是 Java 所特有的**分布式计算技术**，它允许运行在一个 Java 虚拟机上的对象调用运行在另一个 Java 虚拟机上的对象的方法，从而使 Java 编程人员可以方便地在网络环境中作分布式计算。面向对象设计要求每个任务由最适合该任务的对象执行，RMI 将这个概念更深入了一步，使任务可以在最适合该任务的机器上完成。 RMI 定义了一组远程接口，可以用于生成远程对象。客户机可以向调用本地对象的方法一样用相同的语法调用远程对象。RMI API 提供的类和方法可以处理所有访问远程方法的基础通信和参数引用要求的串行化。   使用 RMI 开发步骤： 1、定义一个远程接口（远程接口必须继承接口，每个方法必须抛出远程异常，方法参数和方法返回值都必须是可序列化的）   2、实现远程接口 3、定义使用远程对象的客户程序   4、产生远程访问对象的桩和框   5、注册远程对象   6、运行服务器和客户程序

**答案二：**

Java 远程方法调用(Java RMI)是Java API对远程过程调用 ( RPC ) 提供的面向对象的等价形式，支持直接传输序列化的 Java 对象和分布式垃圾回收。远程方法调用可以看做是激活远程正在运行的对象上的方法的步骤。RMI 对调用者是位置透明的，因为调用者感觉方法是执行在本地运行的对象上的。

## 什么是 Servlet ？

servlet 是基于 Java 语言的 web 服务器端编程技术，是 sun 提供的一种实现动态网页的解决方案。servlet 是运行在 servlet 容器中的 Java 类，它能处理客户端的 HTTP 请求并产生 HTTP 响应。

使用过程：**加载–初始化–服务(doGet/doPost)–销毁–卸载**。一个 Servlet 实例只会创建一次，重复调用的只是service 过程。

## 说一下Servlet的体系结构。

Servlet类 ← GenericServlet 类 ← HttpServlet 类 ← MyServlet 类(自己建的类) （←代表继承）。 

Servlet 类包含所需的三个必要的生命周期方法：init() 初试化 Servlet、service() 相应 Servlet 请求、destroy() 销毁 Servlet，但直接继承需要重写所有方法，所以 GenericServlet 类继承了 Servlet 类并实现了所有方法，但它不是 HTTP 协议类，所以又由 HttpServlet 类继承 GenericServlet 类并是 HTTP 协议类。 

所以我们在建立 Servlet 类时只需继承 HttpServlet 类，重写我们需要的 doGet()、doPost() 请求即可，这两个方法对应客户端的 get 和 post 请求。

![](http://qiniu.zhouhongyin.top/2022/06/12/1655042846-1350993311_7168.png)

## GenericServlet和HttpServlet有什么区别？

**GenericServlet** 

GenericServlet 类实现了Servlet和 ServletConfig 接口。实现了除了service()之外的其他方法，在创建Servlet对象时，可以继承 GenericServlet 类来简化程序的代码，但需要实现 service() 方法。 

  这是 Java 体系一惯的做法，给接口搭配一个抽象类**，**对一些通用的方法做实现，其余方法给出空的实现(必须由子类实现的方法除外**)**，这样程序员开发时直接继承该抽象类，可以大大减少代码数量，避免了实现所有接口方法的呆板操作。

**HttpServlet** 

针对 HTTP 请求，再次对 GenericServlet 方法进行简化，在 service 方法中把传入的 ServletReuqest 和 ServletResponse 转为 HttpServletRequest 和 HttpServletResponse，方便处理HTTP请求。

并且 HttpServlet 还提供了 doGet 和 doPost 方法，更加适用与  HTTP 协议，实际开发中，直接继承 HttpServlet，并根据请求方式复写 doXxx() 方法即可。

## 解释下Servlet的生命周期。

Servlet 程序是由 WEB 服务器调用，web 服务器收到客户端的 Servlet 访问请求后： 

1. Web 服务器首先检查是否已经装载并创建了该 Servlet 的实例对象。如果是，则直接执行第 ④ 步，否则，执行第 ② 步。
2. 装载并创建该 Servlet 的一个实例对象。
3. 调用Servlet实例对象的 init() 方法。
4. 创建一个用于封装 HTTP 请求消息的 HttpServletRequest 对象和一个代表 HTTP 响应消息的HttpServletResponse 对象，然后调用 Servlet 的 service() 方法并将请求和响应对象作为参数传递进去。
5. WEB 应用程序被停止或重新启动之前，Servlet 引擎将卸载 Servlet，并在卸载之前调用 Servlet 的 destroy() 方法。

![](http://qiniu.zhouhongyin.top/2022/06/12/1655042849-466357877_1553498573771_ACED241801E307EE7A39612F85A94EBF.png)

**加载类**=>**实例化**(为对象分配空间)=>**初始化**(**为对象的属性赋值**)=>**请求处理**(服务阶段)=>**销毁**

## doGet() 方法和 doPost() 方法有什么区别？

get 方式是将请求参数放在 action 属性指定的 url 中，因为 url 大小是有规定的，所以 get 方式传输的参数收到大小限制，一般不大于 2kb，而且因为 url 会在浏览器地址栏直接显示，所以保密性不强，为了安全，get 一般只是用于从服务器获取数据；

post 方式是将请求参数放在请求体中，所以大小一般不受限制，保密性也比 get 强，post 一般用于修改、上传和删除服务器资源。

## 什么是Web应用程序？

web 应用程序就是一种可以通过 web 进行访问的应用程序，简单的说就是可以直接通过浏览器进行访问的应用程序。

web 应用程序由若干个 Servlet，JSP 页面，HTML 页面及图形界面构成，是一套完整的服务。

web 应用程序基于典型的 B/S模式（Browser/Server，浏览器/服务器模式）的应用程序，核心是对数据库的相关操作和处理。

## 什么是服务端包含(Server Side Include)？

服务端包含 (SSI) 是一种简单的解释型服务端脚本语言，大多数时候仅用在Web上，用 servlet 标签嵌入进来，是在页面被提供时由服务器端进行运算，以对现有 HTML 页面增加动态生成的内容；

SSI 最常用的场景把一个或多个文件包含到 Web 服务器的一个 Web 页面中。当浏览器访问 Web 页面的时候，Web 服务器会用对应的 servlet 产生的文本来替换 Web 页面中的 servlet 标签。

## 什么是Servlet链 (Servlet Chaining)？

Servlet 链是把一个 Servlet 的输出发送给另一个 Servlet 的方法。第二个 Servlet 的输出可以发送给第三个Servlet，依次类推。链条上最后一个 Servlet 负责把响应发送给客户端。

## 如何知道是哪一个客户端的机器正在请求你的Servlet？

ServletRequest 类可以找出客户端机器的IP地址或者是主机名。getRemoteAddr() 方法获取客户端主机的 IP 地址，getRemoteHost() 可以获取主机名。

```java
request.getRemoteAddr();//ipaddr
request.getRemoteHost();//主机名
request.getRequestURL();//返回全路径
request.getRequestURI();//返回除去host（域名或者ip）部分的路径
request.getContextPath();//返回工程名部分，如果工程映射为/，此处返回则为空
request.getServletPath();//返回除去host和工程名部分的路径
```

## HTTP响应的结构是怎么样的？

- HTTP 响应由三部分组成：状态行、响应头、响应正文； 
  - 响应行：包括协议版本Version、状态码Status Code、回应短语； 
  - 响应头：包括搭建服务器的软件，发送响应的时间，回应数据的格式等信息； 
  - 响应正文：就是响应的具体数据。 

![](http://qiniu.zhouhongyin.top/2022/06/12/1655042853-2012020914293943.png)

- HTTP请求由状态行、请求头、请求正文三部分组成：
  - 请求行：包括请求方式Method、资源路径URL、协议版本Version；
  - 请求头：包括一些访问的域名、用户信息、Cookie等信息；
  - 请求正文：就是HTTP请求的数据。

![](http://qiniu.zhouhongyin.top/2022/06/12/1655042855-2012021309365350.png)

## 什么是cookie？session和cookie有什么区别？

cookie 实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户的状态，就使用response 向客户端浏览器颁发一个 cookie 。客户端浏览器会把 cookie 保存起来。当浏览器再次请求该网站时，浏览器就会把请求地址和 cookie 一同给服务器。服务器检查该 cookie，从而判断用户的状态。服务器还可以根据需要修改 cookie 的内容。 

session 是另一种记录客户状态的机制。不同的是 cookie 保存在客户端浏览器中，而 session 保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是 session。客户端浏览器再次访问时只需要从该 session 中查找该客户的状态就可以了。 如果说 cookie 机制是通过检查客户身上的“通信证”，那么 session 机制就是通过检查服务器上的“客户明细表”来确认客户身份。

> 第一次访问时，服务器会创建一个新的 session，并且把 session 的 Id 以 cookie 的形式发送给客户端浏览器。第二次访问时候，浏览器交出 cookie ，服务器找到对应的 Session 。当浏览器禁用了cookie 后，用URL 重写（后面带上一个类似 cookie 的东西）这种解决方案解决 Session 数据共享问题。

**总结：**

1、存储位置不同，Cookie在浏览器端存储，Session在服务器端存储；

 2、存储容量不同，Cookie存储容量很小，Session存储容量可以很大；

 3、安全性不同，Cookie安全性较低，Session安全性很高；

## 浏览器和Servlet通信使用的是什么协议？

HTTP

## 什么是HTTP隧道？

[什么是HTTP隧道，怎么理解HTTP隧道呢](https://www.cnblogs.com/forforever/p/14093716.html)

HTTP隧道是一种利用HTTP或者是HTTPS把多种网络协议封装起来进行通信的技术。因此，HTTP协议扮演了一个打通用于通信的网络协议的管道的包装器的角色。把其他协议的请求掩盖成HTTP的请求就是HTTP隧道。



有时候需要访问服务器除了80端口之外的其他端口，但是服务器上装有的防火墙软件 会阻止客户端访问除了80端口之外的其他端口，这个时候需要将访问其他端口的协议“包装”一下 变成访问80端口的http协议，这个就是http隧道

## sendRedirect() 和 forward() 方法有什么区别？

**URL重定向的特点**:  

- 浏览器地址栏路径发送变化
- 发送了两个请求
- 因为是不同的请求，所以不能共享请求中的数据
- 可以跨域访问资源
- 不可以访问 WEB-INF 中的资源

**请求转发的特点**:   

- 浏览器地址栏路径没变
- 只发送了一个请求
- 共享同一个请求，在请求内共享数据
- 只能访问当前应用中的资源，不能跨域跳转
- 可以访问 WEB-INF 中的资源

**请求转发和 URL 重定向的选择**?    

- 若需要共享请求中的数据，只能使用请求转发
- 若需要访问 WEB-INF 中的资源,只能使用请求转发
- 若需要跨域访问，只能使用URL重定向
- 请求转发可能造成表单的重复提交问题.    
- 其他时候，任选

forward() 是**服务器内部**的跳转，**浏览器的地址栏不会发生变化**，同时可以把 **request 和 response 传递给后一个请求**。

sendRedirect() 是**浏览器方面**的跳转，要发送**两次请求**，**地址栏也会发生变化**，同时 **request 和 response 也会发生变化，重新生成新的对象**。

## 什么是URL编码和URL解码？

首先 URL 在网络中传输时使用 ASCII 编码的，也就是说，在浏览器中一个 请求发出去最终是使用 ASCII 编码的，这样子要是我们发出去的请求中包含有非 ASCII 字符（不安全的字符，例如中文）的话，就会被浏览器编码，但是，各个浏览器对于 URL 的编码方式是不一样的！！！ 这就会导致很大的问题，同一个 URL 在不同的浏览器中实际发出的 URL 都不一样了，服务器还要 怎么解析这些请求的？  要解决这个问题效率最最高的方法就是在前端中对要发出的 URL 使用 JS 进行编码，编码后的 URL 就只剩下 ASCII 编码中有的字符了。这就是URL编码。  

既然在客户端和已经使用了URL编码了，在服务器端肯定要使用URL解码了。

## 面向对象软件开发的优点有哪些？

相对于面向过程来说，面向对象大大地实现了降耦，从而提高了代码复用性、灵活性，因此实现了代码的模块化。

面向对象编程有很多重要的特性，比如：封装，继承，多态和抽象。

> **封装：**通过关键字将类中的成员变量，成员方法设置访问权限，保证了代码的安全性，提高代码的可复用性，在实际开发时站在使用者的角度封装，当其他人调用该方法时通过方法名就可以明白方法所执行的任务，可简化开发的复杂性。
>
> **继承：**子类对父类有很强的耦合度，一般在开发 web 项目，可以将对数据库操作的 crud 封装成一个公用的父类，供项目中各模块调用，提高代码的复用性。
>
> **多态：**他的本质是由子类的重载和重写实现，在 web 开发中使用面向接口编程提高了项目的可扩展性，接口只需要提供功能，具体的实现让他的子类去做。

## 封装的定义和好处有哪些？

**什么是封装？**

利用抽象数据类型将数据和数据有关的操作封装起来，构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能的隐藏内部细节，只提供一些对外的接口使其与外部发生联系。使用者不需要关心封装内部的细节，但可以调用接口来访问该对象。（封装就是将属性私有化，提供公有的方法访问私有属性。）

做法就是：修改属性的可见性来限制对属性的访问，并为每个属性创建一对取值（getter）方法和赋值（setter）方法，用于对这些属性的访问。

**为什么需要封装？**

通过封装，可以实现对属性的数据访问限制，同时增加了程序的可维护性。

由于取值方法和赋值方法隐藏了实现的变更，因此并不会影响读取或修改该属性的类，避免了大规模的修改，程序的可维护性增强。

**封装的好处：**

减小耦合

提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。

提高可重用性

通过隐藏对象的属性来保护对象内部的状态，提高数据的安全性

## 多态的定义？

**多态：**相同类型的引用变量，调用同一个方法时呈现出多种不同的行为特征（父类的引用指向子类的实例）。 对象的实例变量不具备多态性。 

多态的产生：Java 引用型变量有两个类型：编译时类型，运行时类型 。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。如果编译时类型和运行时类型不一致，就可能出现多态（Polymorphism）

## 继承的定义？

继承是一种类与类之间的关系，利用一个已经存在的类，快速的创建新的类的机制，被继承的类称为父类/超类，继承者称为子类（得到继承的类为子类），子类继承父类，拥有父类所有属性和方法（除私有外）

好处是提高了代码的重用性，可扩展性。

## 抽象的定义？抽象和封装的不同点？

**答案一：**

**抽象：**就是把现实生活中的某一类东西提取出来，用程序代码表示，我们通常叫做类或者接口。抽象包括两个方面：一个是数据抽象，一个是过程抽象。数据抽象也就是对象的属性。过程抽象是对象的行为特征。 

**封装：**是将通过抽象所得到的数据信息和操作进行结合，使其形成一个有机的整体。对内执行操作，对外隐藏细节和数据信息。封装分为属性的封装和方法的封装。

**区别：**抽象是一种思维方式，而封装则是一种基于抽象性的操作方法。我们通过抽象所得到数据信息及其功能，以封装的技术将其重新聚合，形成一个新的聚合体，也就是类。或者说，两者是合作者的关系，如果没有抽象，封装就无从谈起，如果没有封装，抽象也将没有意义。 

**答案二：**

抽象是指从具体事物中概括出它们的共性的思维过程，即把具体事物的属性和行为抽象成字段和方法的过程。

封装是指将抽象得到的数据信息及其功能进行聚合的过程。 

通过观察一定数量的狗，发现它们都有嘴、牙齿和舌头，并且它们都能通过以上属性完成吃东西这个动作（个人认为动作的本质是属性发生变化的过程）。其实这个通过观察得到共性特征的过程就是抽象，然后把这些共性特征都联系到狗身上的过程就是封装。平时我们说的抽象出一个狗类，其实是先将狗的共性特征抽象出来并通过封装将这些共性特征聚合起来放到狗身上（如果没有聚合起来，那么那些共性特征就会变得没有意义）的过程。